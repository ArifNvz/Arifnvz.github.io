{"title":"se importan las bibliotecas necesarias","markdown":{"yaml":{"jupyter":"python3"},"headingText":"se importan las bibliotecas necesarias","containsRefs":false,"markdown":"\n\n#1A. Reporte escrito. Experimentos y análisis\n\nARIF NARVAEZ DE LA O\n\n#INTRODUCCION\nEl análisis de la complejidad algorítmica es una de las áreas fundamentales en la teoría de la computación, ya que permite estimar el rendimiento de un algoritmo en función del tamaño de su entrada. Este análisis se realiza mediante las notaciones de orden de crecimiento, que nos permiten clasificar los algoritmos según su eficiencia a medida que aumenta el tamaño de la entrada (Cormen et al., 2009). Estas notaciones, como O(1), O(log n), O(n), O(n log n), O(n²), O(n³), O(a^n), O(n!) y O(n^n), representan diferentes tasas de crecimiento y ayudan a comparar la eficiencia de distintos algoritmos bajo condiciones similares (Sedgewick & Wayne, 2011).\n\nEn este reporte, realizamos una simulación para comparar estos órdenes de crecimiento y analizar sus tiempos de ejecución en función de diferentes tamaños de entrada. El propósito es entender cómo se comportan los algoritmos con distintos órdenes de crecimiento y cuáles son más adecuados para manejar grandes volúmenes de datos.\n\n```{python}\n#| executionInfo: {status: ok, timestamp: 1738620547794, user_tz: 360, elapsed: 180, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n```\n\nDefinimos las funciones de complejidad para cada orden de crecimiento\nVamos a definir las funciones de cada orden de crecimiento que vamos a comparar.\n\n```{python}\n#| executionInfo: {status: ok, timestamp: 1738620601238, user_tz: 360, elapsed: 184, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ndef O1(n):\n    return np.ones_like(n)\n\ndef Ologn(n):\n    return np.log2(n)\n\ndef On(n):\n    return n\n\ndef Onlogn(n):\n    return n * np.log2(n)\n\ndef On2(n):\n    return n**2\n\ndef On3(n):\n    return n**3\n\ndef Oan(n):\n    return np.exp(n)\n\ndef Onfact(n):\n    # n! crece muy rápido, así que con valores grandes de n podría ser inabordable.\n    return np.array([np.math.factorial(x) for x in n])\n\ndef Onn(n):\n    return n**n\n```\n\nGeneramos las gráficas de comparación entre los órdenes de crecimiento. Cada una de estas comparaciones será una figura.\n\n```{python}\n#| executionInfo: {status: ok, timestamp: 1738627615138, user_tz: 360, elapsed: 155, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\nn_values_small = np.arange(1, 21)  # se limita  n entre 1 y 20 para evitar numeros muy grandes\nn_values = np.arange(1, 10000)  # para O(1), O(log n), O(n), O(n log n), O(n²), O(n³)\ny_O1 = O1(n_values)\ny_Ologn = Ologn(n_values)\ny_On = On(n_values)\ny_Onlogn = Onlogn(n_values)\ny_On2 = On2(n_values)\ny_On3 = On3(n_values)\n```\n\n##1. O(1) vs O(log n)\n\nO(1) es el más eficiente, ya que su tiempo de ejecución es constante, independientemente del tamaño de la entrada. En comparación, O(log n) el tiempo crece lentamente conforme n aumenta. En los resultados de la simulación, O(1) se mantuvo constante, mientras que O(log n) creció poco a poco, aunque de forma manejable.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 565}\n#| executionInfo: {status: ok, timestamp: 1738627617168, user_tz: 360, elapsed: 401, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\nplt.figure(figsize=(10,6))\nplt.plot(n_values, y_O1, label='O(1)', color='r')\nplt.plot(n_values, y_Ologn, label='O(log n)', color='b')\nplt.title('Comparación de O(1) vs O(log n)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##2. O(n) vs O(n log n)\nLos algoritmos con complejidad O(n) crecen linealmente como se puede observar en la grafica. Por otro lado, O(n log n) tiene un pequeño crecimiento adicional por el término logarítmico, que se vuelve significativo a medida que n aumenta. En las simulaciones, O(n log n) empezó a mostrar tiempos mayores conforme aumentaba n, aunque no tanto como O(n²).\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 565}\n#| executionInfo: {status: ok, timestamp: 1738627623491, user_tz: 360, elapsed: 338, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ny_On = On(n_values)\ny_Onlogn = Onlogn(n_values)\n\nplt.figure(figsize=(10,6))\nplt.plot(n_values, y_On, label='O(n)', color='r')\nplt.plot(n_values, y_Onlogn, label='O(n log n)', color='b')\nplt.title('Comparación de O(n) vs O(n log n)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##3. O(n²) vs O(n³)\nAmbos son órdenes polinómicos, pero O(n³) crece mucho más rápido que O(n²). Aunque ambos parecen razonables para n pequeños, el crecimiento de O(n³) es más pronunciado, volviéndose mucho más lento cuando n es grande. O(n³) mostró tiempos de ejecución significativamente mayores que O(n²) en la simulación.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 565}\n#| executionInfo: {status: ok, timestamp: 1738627626573, user_tz: 360, elapsed: 331, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ny_On2 = On2(n_values)\ny_On3 = On3(n_values)\n\nplt.figure(figsize=(10,6))\nplt.plot(n_values, y_On2, label='O(n²)', color='r')\nplt.plot(n_values, y_On3, label='O(n³)', color='b')\nplt.title('Comparación de O(n²) vs O(n³)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##4. O(a^n) vs O(n!)\nTanto O(a^n) como O(n!) son de crecimiento exponencial y factorial, respectivamente, lo que significa que ambos se vuelven imprácticos rápidamente para cualquier tamaño de n relativamente grandr. En la simulación, ambos órdenes alcanzaron tiempos de ejecución tan altos que no fueron viables ni siquiera con entradas de tamaño moderado.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 600}\n#| executionInfo: {status: ok, timestamp: 1738627738869, user_tz: 360, elapsed: 674, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\n# limitamos n porque los valores crecen muy rápido\nn_values_small = np.arange(1, 7)  # se probaron distintos valores y se considera que en el 7 se aprecia mejor el cambio del incremento entre las funciones\ny_Oan = Oan(n_values_small)\ny_Onfact = Onfact(n_values_small)\nplt.figure(figsize=(10,6))\nplt.plot(n_values_small, y_Oan, label='O(a^n)', color='r')\nplt.plot(n_values_small, y_Onfact, label='O(n!)', color='b')\nplt.title('Comparación de O(a^n) vs O(n!)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##5. O(n!) vs O(n^n)\nFinalmente, O(n^n) crece mucho más rápido que O(n!). Ambos son tan ineficientes para tamaños grandes de entrada que en la simulación no pudieron manejarse más allá de valores pequeños de n. Esto resalta lo poco prácticos que son estos algoritmos, incluso para datos de tamaño mediano.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 600}\n#| executionInfo: {status: ok, timestamp: 1738627795843, user_tz: 360, elapsed: 355, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ny_Onfact = Onfact(n_values_small)\ny_Onn = Onn(n_values_small)\n\nplt.figure(figsize=(10,6))\nplt.plot(n_values_small, y_Onfact, label='O(n!)', color='r')\nplt.plot(n_values_small, y_Onn, label='O(n^n)', color='b')\nplt.title('Comparación de O(n!) vs O(n^n)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##RESUMEN DE LO OBSERVADO\nLos resultados obtenidos en la simulación muestran que, a medida que el tamaño de la entrada crece, los algoritmos con complejidades como O(n²) y O(n³) se vuelven significativamente más lentos. Esto se debe al crecimiento polinómico de sus tiempos de ejecución. Por el contrario, los algoritmos con complejidades más eficientes, como O(1) y O(log n), mantienen tiempos de ejecución bajos incluso con entradas más grandes. Esto demuestra que, en situaciones prácticas, es crucial seleccionar algoritmos con menor orden de crecimiento para obtener un rendimiento óptimo (Goodrich & Tamassia, 2014).\n\nAdemás, los algoritmos con complejidades exponenciales y factoriales, como O(a^n) y O(n!), no son viables para tamaños de entrada relativamente pequeños, lo que limita su uso a problemas muy específicos y de pequeño tamaño (Van Emden, 2000).\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 244}\n#| executionInfo: {status: ok, timestamp: 1738627439037, user_tz: 360, elapsed: 138, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\n# Tiempos de ejecución para los tamaños de entrada especificados\nn_values_exec = [1, 10, 100, 1200]\n\n# Crear una tabla con los tiempos estimados\ntable = []\nfor n in n_values_exec:\n    row = [\n        n,\n        O1(np.array([n]))[0],\n        Ologn(np.array([n]))[0],\n        On(np.array([n]))[0],\n        Onlogn(np.array([n]))[0],\n        On2(np.array([n]))[0],\n        On3(np.array([n]))[0],\n        Oan(np.array([n]))[0],\n        Onfact(np.array([n]))[0],\n        Onn(np.array([n]))[0]\n    ]\n    table.append(row)\n\n# Mostrar la tabla\nimport pandas as pd\ndf = pd.DataFrame(table, columns=[\n    'n', 'O(1)', 'O(log n)', 'O(n)', 'O(n log n)', 'O(n²)', 'O(n³)', 'O(a^n)', 'O(n!)', 'O(n^n)'\n])\ndf\n```\n\n#CONCLUSIONES\nEl análisis realizado ha demostrado cómo diferentes órdenes de crecimiento afectan los tiempos de ejecución de los algoritmos. A medida que analizamos los resultados, quedó claro que los algoritmos con complejidades como O(1) y O(log n) son mucho más eficientes y prácticos para entradas grandes. Mientras que los de orden O(n²) o O(n³) pueden ser viables para tamaños pequeños o medianos de entrada, los algoritmos con complejidades O(a^n), O(n!) o O(n^n) se vuelven rápidamente inalcanzables. Esto demuestra la importancia de elegir el algoritmo adecuado según el tamaño de los datos y el tipo de problema a resolver\n\n#REFERENCIAS\n•  Goodrich, M. T., & Tamassia, R. (2014). Data structures and algorithms in Python. Wiley.\n\n•  Sedgewick, R., & Wayne, K. (2011). Algorithms (4th ed.). Addison-Wesley.\n\n•  Van Emden, M. H. (2000). Algorithms and complexity: The theory and practice of computing. Oxford University Press.\n\n","srcMarkdownNoYaml":"\n\n#1A. Reporte escrito. Experimentos y análisis\n\nARIF NARVAEZ DE LA O\n\n#INTRODUCCION\nEl análisis de la complejidad algorítmica es una de las áreas fundamentales en la teoría de la computación, ya que permite estimar el rendimiento de un algoritmo en función del tamaño de su entrada. Este análisis se realiza mediante las notaciones de orden de crecimiento, que nos permiten clasificar los algoritmos según su eficiencia a medida que aumenta el tamaño de la entrada (Cormen et al., 2009). Estas notaciones, como O(1), O(log n), O(n), O(n log n), O(n²), O(n³), O(a^n), O(n!) y O(n^n), representan diferentes tasas de crecimiento y ayudan a comparar la eficiencia de distintos algoritmos bajo condiciones similares (Sedgewick & Wayne, 2011).\n\nEn este reporte, realizamos una simulación para comparar estos órdenes de crecimiento y analizar sus tiempos de ejecución en función de diferentes tamaños de entrada. El propósito es entender cómo se comportan los algoritmos con distintos órdenes de crecimiento y cuáles son más adecuados para manejar grandes volúmenes de datos.\n\n```{python}\n#| executionInfo: {status: ok, timestamp: 1738620547794, user_tz: 360, elapsed: 180, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\n# se importan las bibliotecas necesarias\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n```\n\nDefinimos las funciones de complejidad para cada orden de crecimiento\nVamos a definir las funciones de cada orden de crecimiento que vamos a comparar.\n\n```{python}\n#| executionInfo: {status: ok, timestamp: 1738620601238, user_tz: 360, elapsed: 184, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ndef O1(n):\n    return np.ones_like(n)\n\ndef Ologn(n):\n    return np.log2(n)\n\ndef On(n):\n    return n\n\ndef Onlogn(n):\n    return n * np.log2(n)\n\ndef On2(n):\n    return n**2\n\ndef On3(n):\n    return n**3\n\ndef Oan(n):\n    return np.exp(n)\n\ndef Onfact(n):\n    # n! crece muy rápido, así que con valores grandes de n podría ser inabordable.\n    return np.array([np.math.factorial(x) for x in n])\n\ndef Onn(n):\n    return n**n\n```\n\nGeneramos las gráficas de comparación entre los órdenes de crecimiento. Cada una de estas comparaciones será una figura.\n\n```{python}\n#| executionInfo: {status: ok, timestamp: 1738627615138, user_tz: 360, elapsed: 155, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\nn_values_small = np.arange(1, 21)  # se limita  n entre 1 y 20 para evitar numeros muy grandes\nn_values = np.arange(1, 10000)  # para O(1), O(log n), O(n), O(n log n), O(n²), O(n³)\ny_O1 = O1(n_values)\ny_Ologn = Ologn(n_values)\ny_On = On(n_values)\ny_Onlogn = Onlogn(n_values)\ny_On2 = On2(n_values)\ny_On3 = On3(n_values)\n```\n\n##1. O(1) vs O(log n)\n\nO(1) es el más eficiente, ya que su tiempo de ejecución es constante, independientemente del tamaño de la entrada. En comparación, O(log n) el tiempo crece lentamente conforme n aumenta. En los resultados de la simulación, O(1) se mantuvo constante, mientras que O(log n) creció poco a poco, aunque de forma manejable.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 565}\n#| executionInfo: {status: ok, timestamp: 1738627617168, user_tz: 360, elapsed: 401, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\nplt.figure(figsize=(10,6))\nplt.plot(n_values, y_O1, label='O(1)', color='r')\nplt.plot(n_values, y_Ologn, label='O(log n)', color='b')\nplt.title('Comparación de O(1) vs O(log n)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##2. O(n) vs O(n log n)\nLos algoritmos con complejidad O(n) crecen linealmente como se puede observar en la grafica. Por otro lado, O(n log n) tiene un pequeño crecimiento adicional por el término logarítmico, que se vuelve significativo a medida que n aumenta. En las simulaciones, O(n log n) empezó a mostrar tiempos mayores conforme aumentaba n, aunque no tanto como O(n²).\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 565}\n#| executionInfo: {status: ok, timestamp: 1738627623491, user_tz: 360, elapsed: 338, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ny_On = On(n_values)\ny_Onlogn = Onlogn(n_values)\n\nplt.figure(figsize=(10,6))\nplt.plot(n_values, y_On, label='O(n)', color='r')\nplt.plot(n_values, y_Onlogn, label='O(n log n)', color='b')\nplt.title('Comparación de O(n) vs O(n log n)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##3. O(n²) vs O(n³)\nAmbos son órdenes polinómicos, pero O(n³) crece mucho más rápido que O(n²). Aunque ambos parecen razonables para n pequeños, el crecimiento de O(n³) es más pronunciado, volviéndose mucho más lento cuando n es grande. O(n³) mostró tiempos de ejecución significativamente mayores que O(n²) en la simulación.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 565}\n#| executionInfo: {status: ok, timestamp: 1738627626573, user_tz: 360, elapsed: 331, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ny_On2 = On2(n_values)\ny_On3 = On3(n_values)\n\nplt.figure(figsize=(10,6))\nplt.plot(n_values, y_On2, label='O(n²)', color='r')\nplt.plot(n_values, y_On3, label='O(n³)', color='b')\nplt.title('Comparación de O(n²) vs O(n³)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##4. O(a^n) vs O(n!)\nTanto O(a^n) como O(n!) son de crecimiento exponencial y factorial, respectivamente, lo que significa que ambos se vuelven imprácticos rápidamente para cualquier tamaño de n relativamente grandr. En la simulación, ambos órdenes alcanzaron tiempos de ejecución tan altos que no fueron viables ni siquiera con entradas de tamaño moderado.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 600}\n#| executionInfo: {status: ok, timestamp: 1738627738869, user_tz: 360, elapsed: 674, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\n# limitamos n porque los valores crecen muy rápido\nn_values_small = np.arange(1, 7)  # se probaron distintos valores y se considera que en el 7 se aprecia mejor el cambio del incremento entre las funciones\ny_Oan = Oan(n_values_small)\ny_Onfact = Onfact(n_values_small)\nplt.figure(figsize=(10,6))\nplt.plot(n_values_small, y_Oan, label='O(a^n)', color='r')\nplt.plot(n_values_small, y_Onfact, label='O(n!)', color='b')\nplt.title('Comparación de O(a^n) vs O(n!)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##5. O(n!) vs O(n^n)\nFinalmente, O(n^n) crece mucho más rápido que O(n!). Ambos son tan ineficientes para tamaños grandes de entrada que en la simulación no pudieron manejarse más allá de valores pequeños de n. Esto resalta lo poco prácticos que son estos algoritmos, incluso para datos de tamaño mediano.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 600}\n#| executionInfo: {status: ok, timestamp: 1738627795843, user_tz: 360, elapsed: 355, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\ny_Onfact = Onfact(n_values_small)\ny_Onn = Onn(n_values_small)\n\nplt.figure(figsize=(10,6))\nplt.plot(n_values_small, y_Onfact, label='O(n!)', color='r')\nplt.plot(n_values_small, y_Onn, label='O(n^n)', color='b')\nplt.title('Comparación de O(n!) vs O(n^n)')\nplt.xlabel('Tamaño de entrada (n)')\nplt.ylabel('Tiempo estimado')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n##RESUMEN DE LO OBSERVADO\nLos resultados obtenidos en la simulación muestran que, a medida que el tamaño de la entrada crece, los algoritmos con complejidades como O(n²) y O(n³) se vuelven significativamente más lentos. Esto se debe al crecimiento polinómico de sus tiempos de ejecución. Por el contrario, los algoritmos con complejidades más eficientes, como O(1) y O(log n), mantienen tiempos de ejecución bajos incluso con entradas más grandes. Esto demuestra que, en situaciones prácticas, es crucial seleccionar algoritmos con menor orden de crecimiento para obtener un rendimiento óptimo (Goodrich & Tamassia, 2014).\n\nAdemás, los algoritmos con complejidades exponenciales y factoriales, como O(a^n) y O(n!), no son viables para tamaños de entrada relativamente pequeños, lo que limita su uso a problemas muy específicos y de pequeño tamaño (Van Emden, 2000).\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 244}\n#| executionInfo: {status: ok, timestamp: 1738627439037, user_tz: 360, elapsed: 138, user: {displayName: Arif Narváez de la O, userId: '03142251254644870757'}}\n# Tiempos de ejecución para los tamaños de entrada especificados\nn_values_exec = [1, 10, 100, 1200]\n\n# Crear una tabla con los tiempos estimados\ntable = []\nfor n in n_values_exec:\n    row = [\n        n,\n        O1(np.array([n]))[0],\n        Ologn(np.array([n]))[0],\n        On(np.array([n]))[0],\n        Onlogn(np.array([n]))[0],\n        On2(np.array([n]))[0],\n        On3(np.array([n]))[0],\n        Oan(np.array([n]))[0],\n        Onfact(np.array([n]))[0],\n        Onn(np.array([n]))[0]\n    ]\n    table.append(row)\n\n# Mostrar la tabla\nimport pandas as pd\ndf = pd.DataFrame(table, columns=[\n    'n', 'O(1)', 'O(log n)', 'O(n)', 'O(n log n)', 'O(n²)', 'O(n³)', 'O(a^n)', 'O(n!)', 'O(n^n)'\n])\ndf\n```\n\n#CONCLUSIONES\nEl análisis realizado ha demostrado cómo diferentes órdenes de crecimiento afectan los tiempos de ejecución de los algoritmos. A medida que analizamos los resultados, quedó claro que los algoritmos con complejidades como O(1) y O(log n) son mucho más eficientes y prácticos para entradas grandes. Mientras que los de orden O(n²) o O(n³) pueden ser viables para tamaños pequeños o medianos de entrada, los algoritmos con complejidades O(a^n), O(n!) o O(n^n) se vuelven rápidamente inalcanzables. Esto demuestra la importancia de elegir el algoritmo adecuado según el tamaño de los datos y el tipo de problema a resolver\n\n#REFERENCIAS\n•  Goodrich, M. T., & Tamassia, R. (2014). Data structures and algorithms in Python. Wiley.\n\n•  Sedgewick, R., & Wayne, K. (2011). Algorithms (4th ed.). Addison-Wesley.\n\n•  Van Emden, M. H. (2000). Algorithms and complexity: The theory and practice of computing. Oxford University Press.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"variables":{"primary":"#2a7f62","dark":"#1a535c","light":"#f7fff7"},"toc":true,"toc-depth":3,"output-file":"unidad1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":{"light":"cosmo"},"jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}