{"title":"**Introducción**","markdown":{"yaml":{"jupyter":"python3"},"headingText":"**Introducción**","containsRefs":false,"markdown":"\n\n#3A. Reporte escrito. Experimentos y análisis de algoritmos de ordenamiento.\n####MATERIA: Análisis de algoritmos 2025-1\n####ALUMNO: ARIF NARVAEZ DE LA O\n\nEl análisis de algoritmos de ordenamiento es fundamental para entender cómo diferentes métodos pueden resolver un mismo problema de manera más o menos eficiente. En este trabajo, se implementarán y compararán cinco algoritmos de ordenamiento: Bubble Sort, Heapsort, Mergesort, Quicksort y la estructura de datos SkipList. El objetivo es evaluar su rendimiento en términos de tiempo de ejecución y número de operaciones realizadas, utilizando archivos JSON con diferentes niveles de perturbación.\n\nLos archivos JSON contienen listas de números que representan conjuntos de datos con distintos grados de desorden. A través de este análisis, se busca determinar cuál de estos algoritmos es más eficiente para ordenar grandes volúmenes de datos y cómo su rendimiento varía según el nivel de desorden inicial.\n\n#1- IMPORTACION DE LAS LIBRERIAS\n\n```{python}\nimport time\nimport json\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport random\nimport io\n```\n\n#2-RUTA DE ACCESO PARA LOS ARCHIVOS\n\nLa variable ruta almacena la generalidad del path donde se encuentran alojados los archivos y en conjunto de un diccionario se concatenan los nombres de los archivos. La finalidad de crear un ruta por medio de un diccionario es que se presentaron problemas de dimensionalidad al querer guardar os datos cargados en una lista, por ello se opto por mejor crear una funcion que cargue y lea los archivos iterando cada una de las rutas de los archivos para despues aplicar los algoritmos que señala el ejercicio.\n\n```{python}\narchivos_json = {\n    \"lista_post_p016\": \"./archivos/listas-posteo-con-perturbaciones-p=016.json\",\n    \"lista_post_p032\": \"./archivos/listas-posteo-con-perturbaciones-p=032.json\",\n    \"lista_post_p064\": \"./archivos/listas-posteo-con-perturbaciones-p=064.json\",\n    \"lista_post_p128\": \"./archivos/listas-posteo-con-perturbaciones-p=128.json\",\n    \"lista_post_p256\": \"./archivos/listas-posteo-con-perturbaciones-p=256.json\",\n    \"lista_post_p512\": \"./archivos/listas-posteo-con-perturbaciones-p=512.json\"\n}\n```\n\n#3-CARGA Y LECTURA DE LOS DATOS\nLa función\n```\ncargar_json_como_lista\n```\n se encarga de leer un archivo JSON y convertirlo en una lista de listas, lo cual es útil para procesar datos estructurados. Primero, abre el archivo JSON en modo lectura y carga su contenido utilizando la función json.load. Luego se verifica la estructura del JSON cargado: si es un diccionario, extrae los valores (que se espera que sean listas) y los convierte en una lista de listas esta es una medida preventiva para evitar problemas con los tipos de datos a la hora de aplicar los algoritmos; posteriormente si es una lista de listas, la utiliza directamente. Si el archivo JSON no tiene una estructura válida (es decir, no es un diccionario ni una lista de listas), la función lanza una excepción ValueError indicando que la estructura no es compatible.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\n# Función para cargar un archivo JSON como lista de listas\ndef cargar_json_como_lista(ruta_archivo):\n    with open(ruta_archivo, 'r') as archivo:\n        data = json.load(archivo)\n\n    # Verificar si el JSON es un diccionario o una lista\n    if isinstance(data, dict):\n        # Si es un diccionario, extraer las listas de los valores\n        return list(data.values())\n    elif isinstance(data, list):\n        # Si es una lista de listas, usarla directamente\n        return data\n    else:\n        raise ValueError(\"El archivo JSON no tiene una estructura válida.\")\n\n  # Funciones auxiliares para manejo de None\ndef move_nones_to_end(lst):\n    non_nones = [x for x in lst if x is not None]\n    nones = [None] * (len(lst) - len(non_nones))\n    return non_nones + nones\n\ndef move_nones_to_beginning(lst):\n    non_nones = [x for x in lst if x is not None]\n    nones = [None] * (len(lst) - len(non_nones))\n    return nones + non_nones\n```\n\n#4-ALGORITMOS A UTILIZAR\nSe procede a crear un algoritmo con las operaciones necesarias para llevar a cabo los calculos solicitados, estos se declaran en una funcion para posteriormente ser llamada en otra seccion del notebook\n\n```{python}\ndef adaptive_bubble_sort(lst):\n    lst = move_nones_to_end(lst.copy())\n    n = len(lst)\n    operaciones = 0\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            operaciones += 1\n            if lst[j] > lst[j+1]:\n                lst[j], lst[j+1] = lst[j+1], lst[j]\n                operaciones += 1\n                swapped = True\n        if not swapped:\n            break\n    return lst, operaciones\n\ndef heapsort(lst):\n    lst = move_nones_to_end(lst.copy())\n\n    def heapify(arr, n, i, operaciones):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n        operaciones += 2\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            operaciones += 1\n            operaciones = heapify(arr, n, largest, operaciones)\n        return operaciones\n\n    n = len(lst)\n    operaciones = 0\n    for i in range(n // 2 - 1, -1, -1):\n        operaciones = heapify(lst, n, i, operaciones)\n    for i in range(n - 1, 0, -1):\n        lst[i], lst[0] = lst[0], lst[i]\n        operaciones += 1\n        operaciones = heapify(lst, i, 0, operaciones)\n    return lst, operaciones\n\ndef optimized_mergesort(lst):\n    lst = move_nones_to_end(lst.copy())\n\n    def merge(arr, l, m, r, operaciones):\n        n1 = m - l + 1\n        n2 = r - m\n\n        # Usar slicing en lugar de copias completas\n        L = arr[l:m+1]\n        R = arr[m+1:r+1]\n\n        i = j = 0\n        k = l\n\n        while i < n1 and j < n2:\n            operaciones += 1\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < n1:\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < n2:\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n        return operaciones\n\n    def sort(arr, l, r, operaciones):\n        if l < r:\n            m = l + (r - l) // 2\n            operaciones = sort(arr, l, m, operaciones)\n            operaciones = sort(arr, m + 1, r, operaciones)\n            operaciones = merge(arr, l, m, r, operaciones)\n        return operaciones\n\n    operaciones = 0\n    operaciones = sort(lst, 0, len(lst) - 1, operaciones)\n    return lst, operaciones\n\ndef improved_quicksort(lst):\n    lst = move_nones_to_end(lst.copy())\n\n    def partition(arr, low, high, operaciones):\n        # Selección aleatoria del pivote\n        pivot_idx = random.randint(low, high)\n        arr[pivot_idx], arr[high] = arr[high], arr[pivot_idx]\n        pivot = arr[high]\n\n        i = low - 1\n        for j in range(low, high):\n            operaciones += 1\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n                operaciones += 1\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        operaciones += 1\n        return i + 1, operaciones\n\n    def sort(arr, low, high, operaciones):\n        if low < high:\n            pi, operaciones = partition(arr, low, high, operaciones)\n            operaciones = sort(arr, low, pi - 1, operaciones)\n            operaciones = sort(arr, pi + 1, high, operaciones)\n        return operaciones\n\n    operaciones = 0\n    operaciones = sort(lst, 0, len(lst) - 1, operaciones)\n    return lst, operaciones\n\n# Implementación mejorada de Skip List\nclass SkipNode:\n    def __init__(self, value=None, level=0):\n        self.value = value\n        self.forward = [None] * level\n\nclass ImprovedSkipList:\n    def __init__(self, p=0.5):\n        self.p = p\n        self.max_level = 16  # Nivel máximo razonable\n        self.head = SkipNode(level=self.max_level)\n        self.level = 1\n        self.operaciones = 0\n\n    def random_level(self):\n        lvl = 1\n        while random.random() < self.p and lvl < self.max_level:\n            lvl += 1\n            self.operaciones += 1\n        return lvl\n\n    def insert(self, value):\n        update = [None] * self.max_level\n        current = self.head\n\n        for i in range(self.level - 1, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n                self.operaciones += 1\n            update[i] = current\n            self.operaciones += 1\n\n        current = current.forward[0]\n\n        if current is None or current.value != value:\n            new_level = self.random_level()\n\n            if new_level > self.level:\n                for i in range(self.level, new_level):\n                    update[i] = self.head\n                self.level = new_level\n\n            new_node = SkipNode(value, new_level)\n\n            for i in range(new_level):\n                new_node.forward[i] = update[i].forward[i]\n                update[i].forward[i] = new_node\n                self.operaciones += 1\n\n    def to_list(self):\n        result = []\n        current = self.head.forward[0]\n        while current:\n            result.append(current.value)\n            current = current.forward[0]\n        return result\n\ndef skip_list_sort(lst):\n    lst = move_nones_to_end(lst.copy())\n    skip_list = ImprovedSkipList()\n    for item in lst:\n        if item is not None:\n            skip_list.insert(item)\n    return skip_list.to_list() + [None] * (len(lst) - len(skip_list.to_list())), skip_list.operaciones\n```\n\n#5-APLICACION DE LOS ALGORITMOS A LOS DATOS\n\nLa función\n\n```\naplicar_algoritmo_lista\n```\n\n se encarga de aplicar un algoritmo de ordenamiento específico a una lista de datos y medir tanto el tiempo de ejecución como el número de operaciones (comparaciones) realizadas. Primero registra el tiempo inicial antes de ejecutar el algoritmo. Posteriormente llama al algoritmo pasando una copia de la lista original para evitar modificaciones no deseadas. El algoritmo devuelve la lista ordenada y el número de operaciones realizadas. Finalmente, se calcula el tiempo de ejecución restando el tiempo inicial del tiempo actual.\n\n Por alguna razon que no se logro identificar un error relacionado con el tipo de datos de los archivos, lo que no permitia la ejecucion del codigo en algunas listas, por lo que se empleó un \"Try\" por si ocurre algún error durante la ejecución, se captura la excepción y se imprime un mensaje de error, devolviendo \"None\" para el tiempo y las operaciones para poder continuar midiendo aquellos datos a los que si se le puedan aplicar los algoritmos definidos.\n\n```{python}\n\"\"\" --- Funcion que aplica los algoritmos a las listas de datos ---\"\"\"\n\ndef aplicar_algoritmo_lista(lista, algoritmo, nombre_algoritmo):\n    try:\n        inicio_tiempo = time.time()\n        lista_ordenada, operaciones = algoritmo(lista.copy())\n        tiempo_ejecucion = time.time() - inicio_tiempo\n        return tiempo_ejecucion, operaciones\n    except Exception as e:\n        print(f\"Error con {nombre_algoritmo}: {e}\")\n        return None, None\n```\n\n#6-PROCESAMIENTO DE LOS DATOS\nSe procede a aplicar los diferentes algoritmos de ordenamiento a los datos contenidos en los archivos previamente cargados, y almacenar los resultados en un DataFrame para su posterior análisis. Primero, se define un diccionario resultados_totales que servirá para almacenar los resultados de cada algoritmo aplicado, incluyendo el nombre del archivo, el algoritmo utilizado, el tiempo total de ejecución y el número total de operaciones realizadas. Luego, se itera sobre cada archivo JSON, cargando los datos como una lista. Para cada archivo, se aplican los algoritmos de ordenamiento (Bubble Sort, Heapsort, Mergesort, Quicksort y SkipList) a cada columna (lista) de datos, sumando el tiempo de ejecución y las operaciones realizadas. Estos resultados se almacenan en el diccionario resultados_totales. Finalmente, se crea un DataFrame a partir del diccionario y se guarda en un archivo CSV (resultados_totales.csv) para facilitar su visualización y análisis. Este proceso permite comparar el rendimiento de los algoritmos en términos de tiempo y operaciones para diferentes conjuntos de datos.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 384}\n# Procesamiento de datos y generación de resultados\nresultados_totales = {\n    'Archivo': [],\n    'Algoritmo': [],\n    'Tiempo Total (segundos)': [],\n    'Operaciones Totales': []\n}\n\nalgoritmos = [\n    (adaptive_bubble_sort, \"Bubble Sort Adaptativo\"),\n    (heapsort, \"Heapsort\"),\n    (optimized_mergesort, \"Mergesort Optimizado\"),\n    (improved_quicksort, \"Quicksort Mejorado\"),\n    (skip_list_sort, \"SkipList Mejorada\")\n]\n\nfor nombre_archivo, ruta_archivo in archivos_json.items():\n    print(f\"\\nProcesando archivo: {nombre_archivo}...\")\n    datos = cargar_json_como_lista(ruta_archivo)\n\n    for algoritmo, nombre_algoritmo in algoritmos:\n        tiempo_total = 0\n        operaciones_totales = 0\n\n        for lista in datos:\n            tiempo, ops = aplicar_algoritmo_lista(lista, algoritmo, nombre_algoritmo)\n            if tiempo is not None:\n                tiempo_total += tiempo\n                operaciones_totales += ops\n\n        resultados_totales['Archivo'].append(nombre_archivo)\n        resultados_totales['Algoritmo'].append(nombre_algoritmo)\n        resultados_totales['Tiempo Total (segundos)'].append(tiempo_total)\n        resultados_totales['Operaciones Totales'].append(operaciones_totales)\n\n# Crear DataFrame con los resultados\ndf_resultados_totales = pd.DataFrame(resultados_totales)\ndf_resultados_totales.to_csv('resultados_mejorados.csv', index=False)\n```\n\n#7-ALMACENAMIENTO DE LOS DATOS\nSe guardan los datos obtenidos de cada uno de los archivos con los tiempos de ejecucion y comparacion de cada algoritmo para posteriormete realizar un analisis y comparacion de cada uno de ellos\n\n```{python}\n# Crear DataFrame con los resultados totales\ndf_resultados_totales = pd.DataFrame(resultados_totales)\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\ndf_resultados_totales\n```\n\n#8-VISUALIZACION DE LOS RESULTADOS\nSe procede a agrupar por tipo de algoritmo utilizado los tiempos de ejecucion de cada archivo para observar como interactuan los resultados conforme se incrementa el nivel de perturbacion\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\ndf_bubble_sort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Bubble Sort']\ndf_bubble_sort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 237}\ndf_heapsort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Heapsort']\ndf_heapsort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 89}\ndf_mergesort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Mergesort']\ndf_mergesort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 89}\ndf_quicksort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Quicksort']\ndf_quicksort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 89}\ndf_skip_list = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'SkipList']\ndf_skip_list\n```\n\n#9-CONCLUSIONES\nA partir de los resultados mostrados en los dataframes, se observa que:\n\n\n\n*   Bubble Sort fue el algoritmo más lento en todos los casos, con un tiempo de ejecución significativamente mayor y un número de operaciones más elevado en comparación con los demás algoritmos. Esto era esperado debido a su complejidad algorítmica de O(n^2), lo que lo hace ineficiente para conjuntos de datos grandes.\n\n*   Heapsort y Mergesort mostraron un rendimiento similar, con tiempos de ejecución y operaciones totales considerablemente menores que Bubble Sort. Ambos algoritmos tienen una complejidad de O(nlogn), lo que los hace más eficientes para grandes volúmenes de datos.\n\n*   Quicksort fue el algoritmo más rápido en la mayoría de los casos, con un tiempo de ejecución y número de operaciones ligeramente menor que Heapsort y Mergesort. Sin embargo, su rendimiento puede variar dependiendo de la elección del pivote, aunque en este caso no se observaron problemas significativos.\n\n*   SkipList, aunque es una estructura de datos interesante y eficiente para búsquedas e inserciones, no fue tan rápida como los algoritmos de ordenamiento tradicionales en este contexto. Esto se debe a que su implementación requiere más operaciones para mantener la estructura de niveles, lo que aumenta el tiempo de ejecución y el número de operaciones.\n\n\n\n\n\n\n\n\n\n\n\n\n##9.1-Conclusión general\nPodemos concluir que, para conjuntos de datos grandes con diferentes niveles de perturbación, algoritmos como Quicksort, Heapsort y Mergesort son las mejores opciones debido a su eficiencia y estabilidad. Por otro lado, Bubble Sort y SkipList no son recomendables para este tipo de tareas, ya que su rendimiento no escala adecuadamente con el tamaño de los datos. La elección del algoritmo debe basarse en los requisitos específicos de eficiencia y estabilidad, considerando que Quicksort es generalmente la opción más rápida y eficiente.\n\n#REFERENCIAS\n1- H. CORMEN, T., E. LEISERSON, C., L. RIVEST, R., & STEIN, C. (2022). Introduction to algorithms. MIT Press.\n\n2-Sedgewick, R., & Wayne, K. (2011). Algorithms Fourth Edition. Boston: Pearson Education, Inc. .\n\n\n3-GeeksforGeeks. (n.d.). Sorting algorithms. GeeksforGeeks. Recuperado el 05 de marzo de 2025, de https://www.geeksforgeeks.org/sorting-algorithms/?ref=lbp\n\n","srcMarkdownNoYaml":"\n\n#3A. Reporte escrito. Experimentos y análisis de algoritmos de ordenamiento.\n####MATERIA: Análisis de algoritmos 2025-1\n####ALUMNO: ARIF NARVAEZ DE LA O\n\n## **Introducción**\nEl análisis de algoritmos de ordenamiento es fundamental para entender cómo diferentes métodos pueden resolver un mismo problema de manera más o menos eficiente. En este trabajo, se implementarán y compararán cinco algoritmos de ordenamiento: Bubble Sort, Heapsort, Mergesort, Quicksort y la estructura de datos SkipList. El objetivo es evaluar su rendimiento en términos de tiempo de ejecución y número de operaciones realizadas, utilizando archivos JSON con diferentes niveles de perturbación.\n\nLos archivos JSON contienen listas de números que representan conjuntos de datos con distintos grados de desorden. A través de este análisis, se busca determinar cuál de estos algoritmos es más eficiente para ordenar grandes volúmenes de datos y cómo su rendimiento varía según el nivel de desorden inicial.\n\n#1- IMPORTACION DE LAS LIBRERIAS\n\n```{python}\nimport time\nimport json\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport random\nimport io\n```\n\n#2-RUTA DE ACCESO PARA LOS ARCHIVOS\n\nLa variable ruta almacena la generalidad del path donde se encuentran alojados los archivos y en conjunto de un diccionario se concatenan los nombres de los archivos. La finalidad de crear un ruta por medio de un diccionario es que se presentaron problemas de dimensionalidad al querer guardar os datos cargados en una lista, por ello se opto por mejor crear una funcion que cargue y lea los archivos iterando cada una de las rutas de los archivos para despues aplicar los algoritmos que señala el ejercicio.\n\n```{python}\narchivos_json = {\n    \"lista_post_p016\": \"./archivos/listas-posteo-con-perturbaciones-p=016.json\",\n    \"lista_post_p032\": \"./archivos/listas-posteo-con-perturbaciones-p=032.json\",\n    \"lista_post_p064\": \"./archivos/listas-posteo-con-perturbaciones-p=064.json\",\n    \"lista_post_p128\": \"./archivos/listas-posteo-con-perturbaciones-p=128.json\",\n    \"lista_post_p256\": \"./archivos/listas-posteo-con-perturbaciones-p=256.json\",\n    \"lista_post_p512\": \"./archivos/listas-posteo-con-perturbaciones-p=512.json\"\n}\n```\n\n#3-CARGA Y LECTURA DE LOS DATOS\nLa función\n```\ncargar_json_como_lista\n```\n se encarga de leer un archivo JSON y convertirlo en una lista de listas, lo cual es útil para procesar datos estructurados. Primero, abre el archivo JSON en modo lectura y carga su contenido utilizando la función json.load. Luego se verifica la estructura del JSON cargado: si es un diccionario, extrae los valores (que se espera que sean listas) y los convierte en una lista de listas esta es una medida preventiva para evitar problemas con los tipos de datos a la hora de aplicar los algoritmos; posteriormente si es una lista de listas, la utiliza directamente. Si el archivo JSON no tiene una estructura válida (es decir, no es un diccionario ni una lista de listas), la función lanza una excepción ValueError indicando que la estructura no es compatible.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\n# Función para cargar un archivo JSON como lista de listas\ndef cargar_json_como_lista(ruta_archivo):\n    with open(ruta_archivo, 'r') as archivo:\n        data = json.load(archivo)\n\n    # Verificar si el JSON es un diccionario o una lista\n    if isinstance(data, dict):\n        # Si es un diccionario, extraer las listas de los valores\n        return list(data.values())\n    elif isinstance(data, list):\n        # Si es una lista de listas, usarla directamente\n        return data\n    else:\n        raise ValueError(\"El archivo JSON no tiene una estructura válida.\")\n\n  # Funciones auxiliares para manejo de None\ndef move_nones_to_end(lst):\n    non_nones = [x for x in lst if x is not None]\n    nones = [None] * (len(lst) - len(non_nones))\n    return non_nones + nones\n\ndef move_nones_to_beginning(lst):\n    non_nones = [x for x in lst if x is not None]\n    nones = [None] * (len(lst) - len(non_nones))\n    return nones + non_nones\n```\n\n#4-ALGORITMOS A UTILIZAR\nSe procede a crear un algoritmo con las operaciones necesarias para llevar a cabo los calculos solicitados, estos se declaran en una funcion para posteriormente ser llamada en otra seccion del notebook\n\n```{python}\ndef adaptive_bubble_sort(lst):\n    lst = move_nones_to_end(lst.copy())\n    n = len(lst)\n    operaciones = 0\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            operaciones += 1\n            if lst[j] > lst[j+1]:\n                lst[j], lst[j+1] = lst[j+1], lst[j]\n                operaciones += 1\n                swapped = True\n        if not swapped:\n            break\n    return lst, operaciones\n\ndef heapsort(lst):\n    lst = move_nones_to_end(lst.copy())\n\n    def heapify(arr, n, i, operaciones):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n        operaciones += 2\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            operaciones += 1\n            operaciones = heapify(arr, n, largest, operaciones)\n        return operaciones\n\n    n = len(lst)\n    operaciones = 0\n    for i in range(n // 2 - 1, -1, -1):\n        operaciones = heapify(lst, n, i, operaciones)\n    for i in range(n - 1, 0, -1):\n        lst[i], lst[0] = lst[0], lst[i]\n        operaciones += 1\n        operaciones = heapify(lst, i, 0, operaciones)\n    return lst, operaciones\n\ndef optimized_mergesort(lst):\n    lst = move_nones_to_end(lst.copy())\n\n    def merge(arr, l, m, r, operaciones):\n        n1 = m - l + 1\n        n2 = r - m\n\n        # Usar slicing en lugar de copias completas\n        L = arr[l:m+1]\n        R = arr[m+1:r+1]\n\n        i = j = 0\n        k = l\n\n        while i < n1 and j < n2:\n            operaciones += 1\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n\n        while i < n1:\n            arr[k] = L[i]\n            i += 1\n            k += 1\n\n        while j < n2:\n            arr[k] = R[j]\n            j += 1\n            k += 1\n\n        return operaciones\n\n    def sort(arr, l, r, operaciones):\n        if l < r:\n            m = l + (r - l) // 2\n            operaciones = sort(arr, l, m, operaciones)\n            operaciones = sort(arr, m + 1, r, operaciones)\n            operaciones = merge(arr, l, m, r, operaciones)\n        return operaciones\n\n    operaciones = 0\n    operaciones = sort(lst, 0, len(lst) - 1, operaciones)\n    return lst, operaciones\n\ndef improved_quicksort(lst):\n    lst = move_nones_to_end(lst.copy())\n\n    def partition(arr, low, high, operaciones):\n        # Selección aleatoria del pivote\n        pivot_idx = random.randint(low, high)\n        arr[pivot_idx], arr[high] = arr[high], arr[pivot_idx]\n        pivot = arr[high]\n\n        i = low - 1\n        for j in range(low, high):\n            operaciones += 1\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n                operaciones += 1\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        operaciones += 1\n        return i + 1, operaciones\n\n    def sort(arr, low, high, operaciones):\n        if low < high:\n            pi, operaciones = partition(arr, low, high, operaciones)\n            operaciones = sort(arr, low, pi - 1, operaciones)\n            operaciones = sort(arr, pi + 1, high, operaciones)\n        return operaciones\n\n    operaciones = 0\n    operaciones = sort(lst, 0, len(lst) - 1, operaciones)\n    return lst, operaciones\n\n# Implementación mejorada de Skip List\nclass SkipNode:\n    def __init__(self, value=None, level=0):\n        self.value = value\n        self.forward = [None] * level\n\nclass ImprovedSkipList:\n    def __init__(self, p=0.5):\n        self.p = p\n        self.max_level = 16  # Nivel máximo razonable\n        self.head = SkipNode(level=self.max_level)\n        self.level = 1\n        self.operaciones = 0\n\n    def random_level(self):\n        lvl = 1\n        while random.random() < self.p and lvl < self.max_level:\n            lvl += 1\n            self.operaciones += 1\n        return lvl\n\n    def insert(self, value):\n        update = [None] * self.max_level\n        current = self.head\n\n        for i in range(self.level - 1, -1, -1):\n            while current.forward[i] and current.forward[i].value < value:\n                current = current.forward[i]\n                self.operaciones += 1\n            update[i] = current\n            self.operaciones += 1\n\n        current = current.forward[0]\n\n        if current is None or current.value != value:\n            new_level = self.random_level()\n\n            if new_level > self.level:\n                for i in range(self.level, new_level):\n                    update[i] = self.head\n                self.level = new_level\n\n            new_node = SkipNode(value, new_level)\n\n            for i in range(new_level):\n                new_node.forward[i] = update[i].forward[i]\n                update[i].forward[i] = new_node\n                self.operaciones += 1\n\n    def to_list(self):\n        result = []\n        current = self.head.forward[0]\n        while current:\n            result.append(current.value)\n            current = current.forward[0]\n        return result\n\ndef skip_list_sort(lst):\n    lst = move_nones_to_end(lst.copy())\n    skip_list = ImprovedSkipList()\n    for item in lst:\n        if item is not None:\n            skip_list.insert(item)\n    return skip_list.to_list() + [None] * (len(lst) - len(skip_list.to_list())), skip_list.operaciones\n```\n\n#5-APLICACION DE LOS ALGORITMOS A LOS DATOS\n\nLa función\n\n```\naplicar_algoritmo_lista\n```\n\n se encarga de aplicar un algoritmo de ordenamiento específico a una lista de datos y medir tanto el tiempo de ejecución como el número de operaciones (comparaciones) realizadas. Primero registra el tiempo inicial antes de ejecutar el algoritmo. Posteriormente llama al algoritmo pasando una copia de la lista original para evitar modificaciones no deseadas. El algoritmo devuelve la lista ordenada y el número de operaciones realizadas. Finalmente, se calcula el tiempo de ejecución restando el tiempo inicial del tiempo actual.\n\n Por alguna razon que no se logro identificar un error relacionado con el tipo de datos de los archivos, lo que no permitia la ejecucion del codigo en algunas listas, por lo que se empleó un \"Try\" por si ocurre algún error durante la ejecución, se captura la excepción y se imprime un mensaje de error, devolviendo \"None\" para el tiempo y las operaciones para poder continuar midiendo aquellos datos a los que si se le puedan aplicar los algoritmos definidos.\n\n```{python}\n\"\"\" --- Funcion que aplica los algoritmos a las listas de datos ---\"\"\"\n\ndef aplicar_algoritmo_lista(lista, algoritmo, nombre_algoritmo):\n    try:\n        inicio_tiempo = time.time()\n        lista_ordenada, operaciones = algoritmo(lista.copy())\n        tiempo_ejecucion = time.time() - inicio_tiempo\n        return tiempo_ejecucion, operaciones\n    except Exception as e:\n        print(f\"Error con {nombre_algoritmo}: {e}\")\n        return None, None\n```\n\n#6-PROCESAMIENTO DE LOS DATOS\nSe procede a aplicar los diferentes algoritmos de ordenamiento a los datos contenidos en los archivos previamente cargados, y almacenar los resultados en un DataFrame para su posterior análisis. Primero, se define un diccionario resultados_totales que servirá para almacenar los resultados de cada algoritmo aplicado, incluyendo el nombre del archivo, el algoritmo utilizado, el tiempo total de ejecución y el número total de operaciones realizadas. Luego, se itera sobre cada archivo JSON, cargando los datos como una lista. Para cada archivo, se aplican los algoritmos de ordenamiento (Bubble Sort, Heapsort, Mergesort, Quicksort y SkipList) a cada columna (lista) de datos, sumando el tiempo de ejecución y las operaciones realizadas. Estos resultados se almacenan en el diccionario resultados_totales. Finalmente, se crea un DataFrame a partir del diccionario y se guarda en un archivo CSV (resultados_totales.csv) para facilitar su visualización y análisis. Este proceso permite comparar el rendimiento de los algoritmos en términos de tiempo y operaciones para diferentes conjuntos de datos.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 384}\n# Procesamiento de datos y generación de resultados\nresultados_totales = {\n    'Archivo': [],\n    'Algoritmo': [],\n    'Tiempo Total (segundos)': [],\n    'Operaciones Totales': []\n}\n\nalgoritmos = [\n    (adaptive_bubble_sort, \"Bubble Sort Adaptativo\"),\n    (heapsort, \"Heapsort\"),\n    (optimized_mergesort, \"Mergesort Optimizado\"),\n    (improved_quicksort, \"Quicksort Mejorado\"),\n    (skip_list_sort, \"SkipList Mejorada\")\n]\n\nfor nombre_archivo, ruta_archivo in archivos_json.items():\n    print(f\"\\nProcesando archivo: {nombre_archivo}...\")\n    datos = cargar_json_como_lista(ruta_archivo)\n\n    for algoritmo, nombre_algoritmo in algoritmos:\n        tiempo_total = 0\n        operaciones_totales = 0\n\n        for lista in datos:\n            tiempo, ops = aplicar_algoritmo_lista(lista, algoritmo, nombre_algoritmo)\n            if tiempo is not None:\n                tiempo_total += tiempo\n                operaciones_totales += ops\n\n        resultados_totales['Archivo'].append(nombre_archivo)\n        resultados_totales['Algoritmo'].append(nombre_algoritmo)\n        resultados_totales['Tiempo Total (segundos)'].append(tiempo_total)\n        resultados_totales['Operaciones Totales'].append(operaciones_totales)\n\n# Crear DataFrame con los resultados\ndf_resultados_totales = pd.DataFrame(resultados_totales)\ndf_resultados_totales.to_csv('resultados_mejorados.csv', index=False)\n```\n\n#7-ALMACENAMIENTO DE LOS DATOS\nSe guardan los datos obtenidos de cada uno de los archivos con los tiempos de ejecucion y comparacion de cada algoritmo para posteriormete realizar un analisis y comparacion de cada uno de ellos\n\n```{python}\n# Crear DataFrame con los resultados totales\ndf_resultados_totales = pd.DataFrame(resultados_totales)\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\ndf_resultados_totales\n```\n\n#8-VISUALIZACION DE LOS RESULTADOS\nSe procede a agrupar por tipo de algoritmo utilizado los tiempos de ejecucion de cada archivo para observar como interactuan los resultados conforme se incrementa el nivel de perturbacion\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\ndf_bubble_sort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Bubble Sort']\ndf_bubble_sort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 237}\ndf_heapsort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Heapsort']\ndf_heapsort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 89}\ndf_mergesort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Mergesort']\ndf_mergesort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 89}\ndf_quicksort = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'Quicksort']\ndf_quicksort\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 89}\ndf_skip_list = df_resultados_totales[df_resultados_totales['Algoritmo'] == 'SkipList']\ndf_skip_list\n```\n\n#9-CONCLUSIONES\nA partir de los resultados mostrados en los dataframes, se observa que:\n\n\n\n*   Bubble Sort fue el algoritmo más lento en todos los casos, con un tiempo de ejecución significativamente mayor y un número de operaciones más elevado en comparación con los demás algoritmos. Esto era esperado debido a su complejidad algorítmica de O(n^2), lo que lo hace ineficiente para conjuntos de datos grandes.\n\n*   Heapsort y Mergesort mostraron un rendimiento similar, con tiempos de ejecución y operaciones totales considerablemente menores que Bubble Sort. Ambos algoritmos tienen una complejidad de O(nlogn), lo que los hace más eficientes para grandes volúmenes de datos.\n\n*   Quicksort fue el algoritmo más rápido en la mayoría de los casos, con un tiempo de ejecución y número de operaciones ligeramente menor que Heapsort y Mergesort. Sin embargo, su rendimiento puede variar dependiendo de la elección del pivote, aunque en este caso no se observaron problemas significativos.\n\n*   SkipList, aunque es una estructura de datos interesante y eficiente para búsquedas e inserciones, no fue tan rápida como los algoritmos de ordenamiento tradicionales en este contexto. Esto se debe a que su implementación requiere más operaciones para mantener la estructura de niveles, lo que aumenta el tiempo de ejecución y el número de operaciones.\n\n\n\n\n\n\n\n\n\n\n\n\n##9.1-Conclusión general\nPodemos concluir que, para conjuntos de datos grandes con diferentes niveles de perturbación, algoritmos como Quicksort, Heapsort y Mergesort son las mejores opciones debido a su eficiencia y estabilidad. Por otro lado, Bubble Sort y SkipList no son recomendables para este tipo de tareas, ya que su rendimiento no escala adecuadamente con el tamaño de los datos. La elección del algoritmo debe basarse en los requisitos específicos de eficiencia y estabilidad, considerando que Quicksort es generalmente la opción más rápida y eficiente.\n\n#REFERENCIAS\n1- H. CORMEN, T., E. LEISERSON, C., L. RIVEST, R., & STEIN, C. (2022). Introduction to algorithms. MIT Press.\n\n2-Sedgewick, R., & Wayne, K. (2011). Algorithms Fourth Edition. Boston: Pearson Education, Inc. .\n\n\n3-GeeksforGeeks. (n.d.). Sorting algorithms. GeeksforGeeks. Recuperado el 05 de marzo de 2025, de https://www.geeksforgeeks.org/sorting-algorithms/?ref=lbp\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"variables":{"primary":"#2a7f62","dark":"#1a535c","light":"#f7fff7"},"toc":true,"toc-depth":3,"output-file":"unidad3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":{"light":"cosmo"},"jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}