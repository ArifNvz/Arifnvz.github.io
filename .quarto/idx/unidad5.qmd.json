{"title":"5A. Reporte escrito. Experimentos y análisis de algoritmos de intersección de conjuntos.","markdown":{"yaml":{"title":"5A. Reporte escrito. Experimentos y análisis de algoritmos de intersección de conjuntos.","jupyter":"python3"},"headingText":"1 Introducción","containsRefs":false,"markdown":"\n\n\nAnalisis de Algoritmos\n\nArif Narvaez de la O.\n\nMay 18, 2025\n\n\n\nEl problema de la intersección de conjuntos es fundamental en muchas áreas de la computación, especialmente en recuperación de información, donde los conjuntos representan listas invertidas de documentos que contienen ciertos términos. Este reporte estudia la eficiencia de diferentes algoritmos de intersección aplicados a listas ordenadas de enteros, modelando costos en tiempo de ejecución y número de comparaciones.\n\nSe implementaron y compararon algoritmos clásicos como Merge, así como algoritmos más sofisticados como Baeza-Yates (parametrizado con bisección y búsquedas adaptativas) y Barbay & Kenyon. Los conjuntos de entrada (A, B, C) se componen de pares, tripletas y tetrapletas de listas ordenadas respectivamente.\n\n# 2 Metodologia y descripcion de los algoritmos\nLos algoritmos fueron implementados en Python dentro de un entorno de Google Colab, montando archivos JSON desde Google Drive. Cada conjunto fue procesado respetando su estructura:\n* Conjunto A: pares de listas.\n* Conjunto B: tripletas de listas.\n* Conjunto C: tetrapletas de listas.\n\n*Librerias Utilizadas*\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nimport json, time\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nfrom itertools import combinations\n```\n\nLos algoritmos utilizados fueron:\n1. Merge (ME): algoritmo de intersección secuencial eficiente para listas del mismo tamaño.\n2. Baeza-Yates (BY): algoritmo recursivo basado en la estrategia dividir para vencer, con tres variantes:\n  * BY-BS: b ́usqueda binaria clásica.\n  * BY-B1 y BY-B2: b ́usquedas no acotadas con diferente crecimiento (doble y lineal).\n3. Barbay & Kenyon (BK): algoritmo adaptativo que utiliza memoria para evitar\ncomparaciones redundantes, recomendado para múltiples listas.\n\n```{python}\n# Comparaciones globales\ncomparisons = 0\ndef reset_comparisons():\n    global comparisons\n    comparisons = 0\n\ndef cmp(a, b):\n    global comparisons\n    comparisons += 1\n    return a == b\n\ndef binary_search(lst, x, start=0):\n    global comparisons\n    left, right = start, len(lst) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        comparisons += 1\n        if lst[mid] < x:\n            left = mid + 1\n        elif lst[mid] > x:\n            right = mid - 1\n        else:\n            return mid\n    return left\n\ndef doubling_search1(lst, x, start=0):\n    i = 1\n    while start + i < len(lst) and lst[start + i] < x:\n        i *= 2\n    return binary_search(lst, x, start + i // 2)\n\ndef doubling_search2(lst, x, start=0):\n    i = 1\n    while start + i < len(lst) and lst[start + i] < x:\n        i += 1\n    return binary_search(lst, x, start)\n\n# Algoritmos a utilizar\ndef merge_intersection(a, b):\n    global comparisons\n    reset_comparisons()\n    i = j = 0\n    result = []\n    while i < len(a) and j < len(b):\n        comparisons += 1\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        elif a[i] < b[j]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef baeza_yates(a, b, search_fn):\n    global comparisons\n    reset_comparisons()\n    def recurse(ax, ay, bx, by):\n        if ax > ay or bx > by: return []\n        mid = (ax + ay) // 2\n        val = a[mid]\n        pos = search_fn(b, val, bx)\n        res = []\n        res += recurse(ax, mid - 1, bx, pos - 1)\n        if pos < len(b) and cmp(b[pos], val): res.append(val)\n        res += recurse(mid + 1, ay, pos + 1, by)\n        return res\n    return recurse(0, len(a)-1, 0, len(b)-1)\n\ndef barbay_kenyon(lists, search_fn=binary_search):\n    global comparisons\n    reset_comparisons()\n    pointers = [0] * len(lists)\n    result = []\n    while True:\n        try:\n            val = lists[0][pointers[0]]\n        except IndexError:\n            break\n        count = 1\n        for i in range(1, len(lists)):\n            pointers[i] = search_fn(lists[i], val, pointers[i])\n            if pointers[i] >= len(lists[i]):\n                return result\n            if cmp(lists[i][pointers[i]], val):\n                count += 1\n            else:\n                val = lists[i][pointers[i]]\n                break\n        if count == len(lists):\n            result.append(val)\n            pointers[0] += 1\n        elif val > lists[0][pointers[0]]:\n            pointers[0] = search_fn(lists[0], val, pointers[0])\n        else:\n            pointers[0] += 1\n    return result\n```\n\n# 3. PROCESAMIENTO DE CONJUNTO DE DATOS\n\n## 3.1 Procesamiento del Conjunto A\nEl Conjunto A consiste en pares de listas almacenadas en un archivo JSON, las cuales son procesadas para calcular sus intersecciones utilizando distintos algoritmos. A continuación,se detalla el procedimiento:\n1. Carga del archivo JSON: Se lee el archivo ubicado en la ruta especificada, el cual contiene una lista de pares de listas. Estos datos se cargan en memoria utilizando la biblioteca json.\n\n2. Preparación de los algoritmos: Se definen funciones para cada algoritmo de intersección (ME, BY-BS, BY-B1, BY-B2 y BK), encapsuladas en un diccionario para su ejecución uniforme.\n3. Ejecución y medición: Para cada par de listas:\n  * Se ordenan ambas listas en orden ascendente.\n  * Se ejecuta cada algoritmo, registrando el tiempo de procesamiento, el número de comparaciones y el tamaño de la intersección resultante.\n4. Visualización de resultados: Los datos obtenidos se almacenan en un DataFrame\ny se generan gr ́aficos de caja para comparar métricas como tiempo de ejecución, comparaciones y tama ̃no de la intersección.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 222}\npath_a = './archivos/postinglists-for-intersection-A-k=2.json'\n\nwith open(path_a) as f:\n    data = json.load(f)\n\nalgos = {\n    'ME': lambda a, b: merge_intersection(a, b),\n    'BY-BS': lambda a, b: baeza_yates(a, b, binary_search),\n    'BY-B1': lambda a, b: baeza_yates(a, b, doubling_search1),\n    'BY-B2': lambda a, b: baeza_yates(a, b, doubling_search2),\n    'BK': lambda a, b: barbay_kenyon([a, b])\n}\n\nresults = []\nfor i, (a, b) in enumerate(data):\n    a, b = sorted(a), sorted(b)\n    for name, func in algos.items():\n        reset_comparisons()\n        t0 = time.time()\n        res = func(a, b)\n        t1 = time.time()\n        results.append({\n            'Group': i, 'Algorithm': name,\n            'Time': t1 - t0,\n            'Comparisons': comparisons,\n            'Length': len(res)\n        })\n\ndf_A = pd.DataFrame(results)\nfor metric in ['Time', 'Comparisons', 'Length']:\n    sns.boxplot(x='Algorithm', y=metric, data=df_A)\n    plt.title(f'{metric} - Conjunto A')\n    plt.show()\n```\n\n# 3.2 Procesamiento del Conjunto B\nEl Conjunto B contiene tripletas de listas almacenadas en un archivo JSON, lo que permite evaluar algoritmos de intersección en un escenario más complejo (k=3). A diferencia del Conjunto A, aqu ́ı se comparan dos enfoques:\n\n* Algoritmo Barbay-Kenyon (BK): Opera directamente sobre las tres listas si-\nmultáneamente.\n\n* Algoritmos por pares: Se aplican intersecciones binarias (ME, BY-BS, BY-B1, BY-B2)\na todas las combinaciones posibles de pares de listas dentro de cada triplete.\n1. Carga del archivo JSON: Se lee el archivo ubicado en postinglists-for-intersection-B-k=3.json, cargando tripletas de listas en memoria.\n2. Preparación de los algoritmos:\n  * BK se ejecuta sobre las tres listas ordenadas.\n  * Los algoritmos por pares (ME, BY-*) se aplican a las combinaciones (0-1, 0-2, 1-2) de cada triplete.\n3. Métricas registradas: Para cada ejecuci ́on se almacena: tiempo, comparaciones y tamaño de la intersección, identificando el algoritmo y el par de listas evaluado (ej:BY-BS (0-1)).\n4. Visualización: Se generan gráficos de caja para comparar m ́etricas entre BK y los algoritmos por pares.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\npath_b = './archivos/postinglists-for-intersection-B-k=3.json'\n\nwith open(path_b) as f:\n    data = json.load(f)\n\nalgos_pair = {\n    'ME': merge_intersection,\n    'BY-BS': lambda a, b: baeza_yates(a, b, binary_search),\n    'BY-B1': lambda a, b: baeza_yates(a, b, doubling_search1),\n    'BY-B2': lambda a, b: baeza_yates(a, b, doubling_search2)\n}\n\nresults = []\nfor i, group in enumerate(data):\n    lists = [sorted(l) for l in group]\n    # aplicar BK al conjunto completo\n    reset_comparisons()\n    t0 = time.time()\n    res = barbay_kenyon(lists, binary_search)\n    t1 = time.time()\n    results.append({\n        'Group': i, 'Algorithm': 'BK',\n        'Time': t1 - t0,\n        'Comparisons': comparisons,\n        'Length': len(res)\n    })\n    # aplicar algoritmos por pares\n    for idx1, idx2 in combinations(range(3), 2):\n        a, b = lists[idx1], lists[idx2]\n        for name, func in algos_pair.items():\n            reset_comparisons()\n            t0 = time.time()\n            res = func(a, b)\n            t1 = time.time()\n            results.append({\n                'Group': i, 'Algorithm': name + f' ({idx1}-{idx2})',\n                'Time': t1 - t0,\n                'Comparisons': comparisons,\n                'Length': len(res)\n            })\n\n# GRAFICAR\ndf_B = pd.DataFrame(results)\nfor metric in ['Time', 'Comparisons', 'Length']:\n    sns.boxplot(x='Algorithm', y=metric, data=df_B)\n    plt.title(f'{metric} - Conjunto B')\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.show()\n```\n\n## 3.3 Procesamiento del Conjunto C\nEl Conjunto C extiende el análisis a tétradas de listas (k=4), lo que permite evaluar elcomportamiento de los algoritmos en un contexto de mayor dimensionalidad. Este enfoque introduce una complejidad adicional al aumentar el número de posibles combinaciones por pares.\n\n1. Carga del archivo JSON: Se lee el archivo ubicado en postinglists-for-intersection-C-k=4.json, cargando t ́etradas de listas en memoria.\n2. Estrategias de intersección:\n * Barbay-Kenyon (BK): Opera directamente sobre las cuatro listas simultáneamente,\naprovechando su dise ̃no para m ́ultiples listas ordenadas.\n  * Algoritmos por pares: Se aplican las mismas t ́ecnicas que en los conjuntos\nanteriores (ME, BY-BS, BY-B1, BY-B2), pero ahora sobre las 42 = 6 combinaciones posibles de pares (0-1, 0-2, 0-3, 1-2, 1-3, 2-3).\n3. Métricas y etiquetado: Cada ejecución registra:\n  * Algorithm: Identificador del algoritmo y par evaluado (ej: BY-BS (0-3)).\n  * Time, Comparisons, Length: Tiempo, comparaciones y tama ̃no de la intersección.\n4. Visualización: Los gráficos de caja permiten comparar el rendimiento de BK frente a las intersecciones por pares, destacando el impacto del aumento de dimensionalidad.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\npath_c = './archivos/postinglists-for-intersection-C-k=4.json'\n\nwith open(path_c) as f:\n    data = json.load(f)\n\nresults = []\nfor i, group in enumerate(data):\n    lists = [sorted(l) for l in group]\n    # BK sobre las 4 listas\n    reset_comparisons()\n    t0 = time.time()\n    res = barbay_kenyon(lists, binary_search)\n    t1 = time.time()\n    results.append({\n        'Group': i, 'Algorithm': 'BK',\n        'Time': t1 - t0,\n        'Comparisons': comparisons,\n        'Length': len(res)\n    })\n    # ME y BY sobre todos los pares\n    for idx1, idx2 in combinations(range(4), 2):\n        a, b = lists[idx1], lists[idx2]\n        for name, func in algos_pair.items():\n            reset_comparisons()\n            t0 = time.time()\n            res = func(a, b)\n            t1 = time.time()\n            results.append({\n                'Group': i, 'Algorithm': name + f' ({idx1}-{idx2})',\n                'Time': t1 - t0,\n                'Comparisons': comparisons,\n                'Length': len(res)\n            })\n\n# GRAFICAR\ndf_C = pd.DataFrame(results)\nfor metric in ['Time', 'Comparisons', 'Length']:\n    sns.boxplot(x='Algorithm', y=metric, data=df_C)\n    plt.title(f'{metric} - Conjunto C')\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.show()\n```\n\n# 4. TABLA GENERAL DE RESULTADOS\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 423}\n# Añadir columna que indique el origen del conjunto\ndf_A['Dataset'] = 'A'\ndf_B['Dataset'] = 'B'\ndf_C['Dataset'] = 'C'\n\ndf_all = pd.concat([df_A, df_B, df_C], ignore_index=True)\n\npd.set_option('display.max_rows', 100)\npd.set_option('display.max_columns', None)\n\ndf_all_sorted = df_all.sort_values(by=['Dataset', 'Group', 'Algorithm']).reset_index(drop=True)\ndisplay(df_all_sorted)\n```\n\n# 5 Análisis de Resultados\nLos datos muestran que:\n* El algoritmo BK mantiene un tiempo de ejecución consistente a través de los diferentes conjuntos, siendo particularmente eficiente para intersecciones m ́ultiples.\n* Las versiones BY-BS y BY-B1 muestran los mejores tiempos para intersecciones binarias, mientras que BY-B2 resulta significativamente más lento.\n* El m ́etodo ME presenta un alto n ́umero de comparaciones pero tiempos competitivos en conjuntos grandes, especialmente en combinaciones por pares.\n\n* Se observa un incremento notable en el n ́umero de comparaciones al aumentar la dimensionalidad de los conjuntos (de A a C).\n\n5.1 Resumen Estadístico\n\nLos resultados consolidados de los tres conjuntos de datos (A, B y C) muestran el comportamiento de los diferentes algoritmos en t ́erminos de tiempo de ejecución, número de comparaciones y tamaño de la intersección. La Tabla 1 presenta los valores promedio para cada combinación de algoritmo y conjunto de datos.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\n# Tabla de resumen estadístico (media)\nsummary = df_all.groupby(['Dataset', 'Algorithm']).agg({\n    'Time': 'mean',\n    'Comparisons': 'mean',\n    'Length': 'mean'\n}).reset_index()\n\n\ndisplay(summary)\n```\n\n# 6 REPRESENTACION GRAFICA DE RESULTADOS ESTADISTICOS\nEl an ́alisis comparativo se implementó mediante el siguiente c ́odigo Python, que genera visualizaciones para cada métrica clave:\n\nEl c ́odigo realiza las siguientes funciones:\n* Define t ́ıtulos descriptivos para cada métrica en español\n* Genera diagramas de caja (boxplots) para visualizar la distribución de:\n  * Tiempos de ejecución (Fig. 4a)\n  * Número de comparaciones (Fig. 4b)\n  * Longitud de las intersecciones (Fig. 4c)\n* Configura el dise ̃no para mejor legibilidad:\n  * Tama ̃no de figura adecuado (12x6 pulgadas) showfliers=True para mostrar valores atípicos\n  * Leyenda externa para evitar solapamientos\n\nLos gráficos resultantes permiten comparar visualmente:\n* La variabilidad de cada algoritmo entre conjuntos\n* La presencia de valores at ́ıpicos en las m ́etricas\n* Las diferencias de rendimiento relativo entre m ́etodos\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\nsns.set_style(\"whitegrid\")\nsns.set_palette(\"husl\")\nplt.rcParams['figure.facecolor'] = 'white'\n\nmetric_config = {\n    'Time': {\n        'title': 'Tiempo de ejecución (segundos)',\n        'yscale': 'log' if df_all['Time'].max()/df_all['Time'].min() > 100 else 'linear',\n        'ylim': (df_all['Time'].min()*0.9, df_all['Time'].max()*1.1)\n    },\n    'Comparisons': {\n        'title': 'Número de comparaciones',\n        'yscale': 'linear',\n        'ylim': (0, df_all['Comparisons'].max()*1.1)\n    },\n    'Length': {\n        'title': 'Longitud de intersección',\n        'yscale': 'linear',\n        'ylim': (0, df_all['Length'].max()*1.1)\n    }\n}\n\n\nfor metric in ['Time', 'Comparisons', 'Length']:\n    plt.figure(figsize=(12, 6))\n\n\n    ax = sns.boxplot(\n        x='Dataset',\n        y=metric,\n        hue='Algorithm',\n        data=df_all,\n        showfliers=True,\n        width=0.6,\n        linewidth=1.5,\n        flierprops=dict(marker='o', markersize=5))\n\n\n    config = metric_config[metric]\n    plt.title(f'{config[\"title\"]} por conjunto y algoritmo', fontsize=14, pad=15)\n    plt.ylabel(config[\"title\"], fontsize=12)\n    plt.xlabel('Conjunto de datos', fontsize=12)\n\n\n    ax.set_yscale(config[\"yscale\"])\n    ax.set_ylim(config[\"ylim\"])\n\n\n    plt.legend(\n        title='Algoritmo',\n        bbox_to_anchor=(1.05, 1),\n        loc='upper left',\n        frameon=True,\n        framealpha=0.8\n    )\n\n\n    ax.yaxis.grid(True, linestyle='--', alpha=0.7)\n    ax.xaxis.grid(False)\n\n    plt.tight_layout()\n    plt.savefig(f'boxplot_{metric}_adjusted.png', dpi=300, bbox_inches='tight')\n    plt.show()\n\n```\n\n# 7 Conclusiones\nLos experimentos realizados sobre los tres conjuntos de datos (A, B y C) permiten extraer conclusiones significativas sobre el comportamiento de los diferentes algoritmos de intersección evaluados.\n\nEn primer lugar, el algoritmo Barbay-Kenyon (BK) demostró ser el más eficiente para intersecciones m ́ultiples, mostrando tiempos de ejecución consistentes a medida que aumentaba la dimensionalidad de los conjuntos. Para el conjunto C (k=4), BK mantuvo un tiempo promedio de solo 0.000865 segundos, significativamente menor que las combinaciones por pares. Sin embargo, este algoritmo requirió un mayor número de comparaciones (3855.715 en promedio para C), lo que sugiere un equilibrio entre tiempo de ejecución y\ncomplejidad computacional.\n\nPor otro lado, los algoritmos basados en b ́usqueda binaria mostraron comportamientos diferenciados. La versión BY-BS fue la más rápida en intersecciones binarias (0.000411s en el conjunto A), mientras que su variante con doubling search (BY-B1) tambi ́en ofreció buenos resultados. En contraste, BY-B2 resultó considerablemente m ́as lento (0.002563s en A), indicando que la estrategia de incremento lineal no es óptima para estos conjuntos de\ndatos.\n\nEl método Merge Intersection (ME) presentó caracter ́ısticas particulares: aunque requirió un número elevado de comparaciones (8106.315 en A), mostró tiempos competitivos en operaciones por pares, especialmente en conjuntos grandes (0.001102s para el par 1-2 en C). Esto sugiere que su simplicidad lo hace viable cuando el nímero de comparaciones no es el factor crítico.\n\nFinalmente, el an ́alisis revel ́o que la densidad de las listas impacta directamente en los resultados. Las intersecciones en el conjunto B mostraron mayor tamaño (hasta 593.670 elementos) comparado con C (máximo 269.180), lo que resalta la importancia de seleccionar el algoritmo seg ́un las caracter ́ısticas especificas de los datos. Para trabajos futuros, se podría explorar el desarrollo de algoritmos híbridos que combinen las fortalezas de estas diferentes aproximaciones.\n\n","srcMarkdownNoYaml":"\n\n\nAnalisis de Algoritmos\n\nArif Narvaez de la O.\n\nMay 18, 2025\n\n\n# 1 Introducción\n\nEl problema de la intersección de conjuntos es fundamental en muchas áreas de la computación, especialmente en recuperación de información, donde los conjuntos representan listas invertidas de documentos que contienen ciertos términos. Este reporte estudia la eficiencia de diferentes algoritmos de intersección aplicados a listas ordenadas de enteros, modelando costos en tiempo de ejecución y número de comparaciones.\n\nSe implementaron y compararon algoritmos clásicos como Merge, así como algoritmos más sofisticados como Baeza-Yates (parametrizado con bisección y búsquedas adaptativas) y Barbay & Kenyon. Los conjuntos de entrada (A, B, C) se componen de pares, tripletas y tetrapletas de listas ordenadas respectivamente.\n\n# 2 Metodologia y descripcion de los algoritmos\nLos algoritmos fueron implementados en Python dentro de un entorno de Google Colab, montando archivos JSON desde Google Drive. Cada conjunto fue procesado respetando su estructura:\n* Conjunto A: pares de listas.\n* Conjunto B: tripletas de listas.\n* Conjunto C: tetrapletas de listas.\n\n*Librerias Utilizadas*\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nimport json, time\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nfrom itertools import combinations\n```\n\nLos algoritmos utilizados fueron:\n1. Merge (ME): algoritmo de intersección secuencial eficiente para listas del mismo tamaño.\n2. Baeza-Yates (BY): algoritmo recursivo basado en la estrategia dividir para vencer, con tres variantes:\n  * BY-BS: b ́usqueda binaria clásica.\n  * BY-B1 y BY-B2: b ́usquedas no acotadas con diferente crecimiento (doble y lineal).\n3. Barbay & Kenyon (BK): algoritmo adaptativo que utiliza memoria para evitar\ncomparaciones redundantes, recomendado para múltiples listas.\n\n```{python}\n# Comparaciones globales\ncomparisons = 0\ndef reset_comparisons():\n    global comparisons\n    comparisons = 0\n\ndef cmp(a, b):\n    global comparisons\n    comparisons += 1\n    return a == b\n\ndef binary_search(lst, x, start=0):\n    global comparisons\n    left, right = start, len(lst) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        comparisons += 1\n        if lst[mid] < x:\n            left = mid + 1\n        elif lst[mid] > x:\n            right = mid - 1\n        else:\n            return mid\n    return left\n\ndef doubling_search1(lst, x, start=0):\n    i = 1\n    while start + i < len(lst) and lst[start + i] < x:\n        i *= 2\n    return binary_search(lst, x, start + i // 2)\n\ndef doubling_search2(lst, x, start=0):\n    i = 1\n    while start + i < len(lst) and lst[start + i] < x:\n        i += 1\n    return binary_search(lst, x, start)\n\n# Algoritmos a utilizar\ndef merge_intersection(a, b):\n    global comparisons\n    reset_comparisons()\n    i = j = 0\n    result = []\n    while i < len(a) and j < len(b):\n        comparisons += 1\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        elif a[i] < b[j]:\n            i += 1\n        else:\n            j += 1\n    return result\n\ndef baeza_yates(a, b, search_fn):\n    global comparisons\n    reset_comparisons()\n    def recurse(ax, ay, bx, by):\n        if ax > ay or bx > by: return []\n        mid = (ax + ay) // 2\n        val = a[mid]\n        pos = search_fn(b, val, bx)\n        res = []\n        res += recurse(ax, mid - 1, bx, pos - 1)\n        if pos < len(b) and cmp(b[pos], val): res.append(val)\n        res += recurse(mid + 1, ay, pos + 1, by)\n        return res\n    return recurse(0, len(a)-1, 0, len(b)-1)\n\ndef barbay_kenyon(lists, search_fn=binary_search):\n    global comparisons\n    reset_comparisons()\n    pointers = [0] * len(lists)\n    result = []\n    while True:\n        try:\n            val = lists[0][pointers[0]]\n        except IndexError:\n            break\n        count = 1\n        for i in range(1, len(lists)):\n            pointers[i] = search_fn(lists[i], val, pointers[i])\n            if pointers[i] >= len(lists[i]):\n                return result\n            if cmp(lists[i][pointers[i]], val):\n                count += 1\n            else:\n                val = lists[i][pointers[i]]\n                break\n        if count == len(lists):\n            result.append(val)\n            pointers[0] += 1\n        elif val > lists[0][pointers[0]]:\n            pointers[0] = search_fn(lists[0], val, pointers[0])\n        else:\n            pointers[0] += 1\n    return result\n```\n\n# 3. PROCESAMIENTO DE CONJUNTO DE DATOS\n\n## 3.1 Procesamiento del Conjunto A\nEl Conjunto A consiste en pares de listas almacenadas en un archivo JSON, las cuales son procesadas para calcular sus intersecciones utilizando distintos algoritmos. A continuación,se detalla el procedimiento:\n1. Carga del archivo JSON: Se lee el archivo ubicado en la ruta especificada, el cual contiene una lista de pares de listas. Estos datos se cargan en memoria utilizando la biblioteca json.\n\n2. Preparación de los algoritmos: Se definen funciones para cada algoritmo de intersección (ME, BY-BS, BY-B1, BY-B2 y BK), encapsuladas en un diccionario para su ejecución uniforme.\n3. Ejecución y medición: Para cada par de listas:\n  * Se ordenan ambas listas en orden ascendente.\n  * Se ejecuta cada algoritmo, registrando el tiempo de procesamiento, el número de comparaciones y el tamaño de la intersección resultante.\n4. Visualización de resultados: Los datos obtenidos se almacenan en un DataFrame\ny se generan gr ́aficos de caja para comparar métricas como tiempo de ejecución, comparaciones y tama ̃no de la intersección.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 222}\npath_a = './archivos/postinglists-for-intersection-A-k=2.json'\n\nwith open(path_a) as f:\n    data = json.load(f)\n\nalgos = {\n    'ME': lambda a, b: merge_intersection(a, b),\n    'BY-BS': lambda a, b: baeza_yates(a, b, binary_search),\n    'BY-B1': lambda a, b: baeza_yates(a, b, doubling_search1),\n    'BY-B2': lambda a, b: baeza_yates(a, b, doubling_search2),\n    'BK': lambda a, b: barbay_kenyon([a, b])\n}\n\nresults = []\nfor i, (a, b) in enumerate(data):\n    a, b = sorted(a), sorted(b)\n    for name, func in algos.items():\n        reset_comparisons()\n        t0 = time.time()\n        res = func(a, b)\n        t1 = time.time()\n        results.append({\n            'Group': i, 'Algorithm': name,\n            'Time': t1 - t0,\n            'Comparisons': comparisons,\n            'Length': len(res)\n        })\n\ndf_A = pd.DataFrame(results)\nfor metric in ['Time', 'Comparisons', 'Length']:\n    sns.boxplot(x='Algorithm', y=metric, data=df_A)\n    plt.title(f'{metric} - Conjunto A')\n    plt.show()\n```\n\n# 3.2 Procesamiento del Conjunto B\nEl Conjunto B contiene tripletas de listas almacenadas en un archivo JSON, lo que permite evaluar algoritmos de intersección en un escenario más complejo (k=3). A diferencia del Conjunto A, aqu ́ı se comparan dos enfoques:\n\n* Algoritmo Barbay-Kenyon (BK): Opera directamente sobre las tres listas si-\nmultáneamente.\n\n* Algoritmos por pares: Se aplican intersecciones binarias (ME, BY-BS, BY-B1, BY-B2)\na todas las combinaciones posibles de pares de listas dentro de cada triplete.\n1. Carga del archivo JSON: Se lee el archivo ubicado en postinglists-for-intersection-B-k=3.json, cargando tripletas de listas en memoria.\n2. Preparación de los algoritmos:\n  * BK se ejecuta sobre las tres listas ordenadas.\n  * Los algoritmos por pares (ME, BY-*) se aplican a las combinaciones (0-1, 0-2, 1-2) de cada triplete.\n3. Métricas registradas: Para cada ejecuci ́on se almacena: tiempo, comparaciones y tamaño de la intersección, identificando el algoritmo y el par de listas evaluado (ej:BY-BS (0-1)).\n4. Visualización: Se generan gráficos de caja para comparar m ́etricas entre BK y los algoritmos por pares.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\npath_b = './archivos/postinglists-for-intersection-B-k=3.json'\n\nwith open(path_b) as f:\n    data = json.load(f)\n\nalgos_pair = {\n    'ME': merge_intersection,\n    'BY-BS': lambda a, b: baeza_yates(a, b, binary_search),\n    'BY-B1': lambda a, b: baeza_yates(a, b, doubling_search1),\n    'BY-B2': lambda a, b: baeza_yates(a, b, doubling_search2)\n}\n\nresults = []\nfor i, group in enumerate(data):\n    lists = [sorted(l) for l in group]\n    # aplicar BK al conjunto completo\n    reset_comparisons()\n    t0 = time.time()\n    res = barbay_kenyon(lists, binary_search)\n    t1 = time.time()\n    results.append({\n        'Group': i, 'Algorithm': 'BK',\n        'Time': t1 - t0,\n        'Comparisons': comparisons,\n        'Length': len(res)\n    })\n    # aplicar algoritmos por pares\n    for idx1, idx2 in combinations(range(3), 2):\n        a, b = lists[idx1], lists[idx2]\n        for name, func in algos_pair.items():\n            reset_comparisons()\n            t0 = time.time()\n            res = func(a, b)\n            t1 = time.time()\n            results.append({\n                'Group': i, 'Algorithm': name + f' ({idx1}-{idx2})',\n                'Time': t1 - t0,\n                'Comparisons': comparisons,\n                'Length': len(res)\n            })\n\n# GRAFICAR\ndf_B = pd.DataFrame(results)\nfor metric in ['Time', 'Comparisons', 'Length']:\n    sns.boxplot(x='Algorithm', y=metric, data=df_B)\n    plt.title(f'{metric} - Conjunto B')\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.show()\n```\n\n## 3.3 Procesamiento del Conjunto C\nEl Conjunto C extiende el análisis a tétradas de listas (k=4), lo que permite evaluar elcomportamiento de los algoritmos en un contexto de mayor dimensionalidad. Este enfoque introduce una complejidad adicional al aumentar el número de posibles combinaciones por pares.\n\n1. Carga del archivo JSON: Se lee el archivo ubicado en postinglists-for-intersection-C-k=4.json, cargando t ́etradas de listas en memoria.\n2. Estrategias de intersección:\n * Barbay-Kenyon (BK): Opera directamente sobre las cuatro listas simultáneamente,\naprovechando su dise ̃no para m ́ultiples listas ordenadas.\n  * Algoritmos por pares: Se aplican las mismas t ́ecnicas que en los conjuntos\nanteriores (ME, BY-BS, BY-B1, BY-B2), pero ahora sobre las 42 = 6 combinaciones posibles de pares (0-1, 0-2, 0-3, 1-2, 1-3, 2-3).\n3. Métricas y etiquetado: Cada ejecución registra:\n  * Algorithm: Identificador del algoritmo y par evaluado (ej: BY-BS (0-3)).\n  * Time, Comparisons, Length: Tiempo, comparaciones y tama ̃no de la intersección.\n4. Visualización: Los gráficos de caja permiten comparar el rendimiento de BK frente a las intersecciones por pares, destacando el impacto del aumento de dimensionalidad.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\npath_c = './archivos/postinglists-for-intersection-C-k=4.json'\n\nwith open(path_c) as f:\n    data = json.load(f)\n\nresults = []\nfor i, group in enumerate(data):\n    lists = [sorted(l) for l in group]\n    # BK sobre las 4 listas\n    reset_comparisons()\n    t0 = time.time()\n    res = barbay_kenyon(lists, binary_search)\n    t1 = time.time()\n    results.append({\n        'Group': i, 'Algorithm': 'BK',\n        'Time': t1 - t0,\n        'Comparisons': comparisons,\n        'Length': len(res)\n    })\n    # ME y BY sobre todos los pares\n    for idx1, idx2 in combinations(range(4), 2):\n        a, b = lists[idx1], lists[idx2]\n        for name, func in algos_pair.items():\n            reset_comparisons()\n            t0 = time.time()\n            res = func(a, b)\n            t1 = time.time()\n            results.append({\n                'Group': i, 'Algorithm': name + f' ({idx1}-{idx2})',\n                'Time': t1 - t0,\n                'Comparisons': comparisons,\n                'Length': len(res)\n            })\n\n# GRAFICAR\ndf_C = pd.DataFrame(results)\nfor metric in ['Time', 'Comparisons', 'Length']:\n    sns.boxplot(x='Algorithm', y=metric, data=df_C)\n    plt.title(f'{metric} - Conjunto C')\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    plt.show()\n```\n\n# 4. TABLA GENERAL DE RESULTADOS\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 423}\n# Añadir columna que indique el origen del conjunto\ndf_A['Dataset'] = 'A'\ndf_B['Dataset'] = 'B'\ndf_C['Dataset'] = 'C'\n\ndf_all = pd.concat([df_A, df_B, df_C], ignore_index=True)\n\npd.set_option('display.max_rows', 100)\npd.set_option('display.max_columns', None)\n\ndf_all_sorted = df_all.sort_values(by=['Dataset', 'Group', 'Algorithm']).reset_index(drop=True)\ndisplay(df_all_sorted)\n```\n\n# 5 Análisis de Resultados\nLos datos muestran que:\n* El algoritmo BK mantiene un tiempo de ejecución consistente a través de los diferentes conjuntos, siendo particularmente eficiente para intersecciones m ́ultiples.\n* Las versiones BY-BS y BY-B1 muestran los mejores tiempos para intersecciones binarias, mientras que BY-B2 resulta significativamente más lento.\n* El m ́etodo ME presenta un alto n ́umero de comparaciones pero tiempos competitivos en conjuntos grandes, especialmente en combinaciones por pares.\n\n* Se observa un incremento notable en el n ́umero de comparaciones al aumentar la dimensionalidad de los conjuntos (de A a C).\n\n5.1 Resumen Estadístico\n\nLos resultados consolidados de los tres conjuntos de datos (A, B y C) muestran el comportamiento de los diferentes algoritmos en t ́erminos de tiempo de ejecución, número de comparaciones y tamaño de la intersección. La Tabla 1 presenta los valores promedio para cada combinación de algoritmo y conjunto de datos.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\n# Tabla de resumen estadístico (media)\nsummary = df_all.groupby(['Dataset', 'Algorithm']).agg({\n    'Time': 'mean',\n    'Comparisons': 'mean',\n    'Length': 'mean'\n}).reset_index()\n\n\ndisplay(summary)\n```\n\n# 6 REPRESENTACION GRAFICA DE RESULTADOS ESTADISTICOS\nEl an ́alisis comparativo se implementó mediante el siguiente c ́odigo Python, que genera visualizaciones para cada métrica clave:\n\nEl c ́odigo realiza las siguientes funciones:\n* Define t ́ıtulos descriptivos para cada métrica en español\n* Genera diagramas de caja (boxplots) para visualizar la distribución de:\n  * Tiempos de ejecución (Fig. 4a)\n  * Número de comparaciones (Fig. 4b)\n  * Longitud de las intersecciones (Fig. 4c)\n* Configura el dise ̃no para mejor legibilidad:\n  * Tama ̃no de figura adecuado (12x6 pulgadas) showfliers=True para mostrar valores atípicos\n  * Leyenda externa para evitar solapamientos\n\nLos gráficos resultantes permiten comparar visualmente:\n* La variabilidad de cada algoritmo entre conjuntos\n* La presencia de valores at ́ıpicos en las m ́etricas\n* Las diferencias de rendimiento relativo entre m ́etodos\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\nsns.set_style(\"whitegrid\")\nsns.set_palette(\"husl\")\nplt.rcParams['figure.facecolor'] = 'white'\n\nmetric_config = {\n    'Time': {\n        'title': 'Tiempo de ejecución (segundos)',\n        'yscale': 'log' if df_all['Time'].max()/df_all['Time'].min() > 100 else 'linear',\n        'ylim': (df_all['Time'].min()*0.9, df_all['Time'].max()*1.1)\n    },\n    'Comparisons': {\n        'title': 'Número de comparaciones',\n        'yscale': 'linear',\n        'ylim': (0, df_all['Comparisons'].max()*1.1)\n    },\n    'Length': {\n        'title': 'Longitud de intersección',\n        'yscale': 'linear',\n        'ylim': (0, df_all['Length'].max()*1.1)\n    }\n}\n\n\nfor metric in ['Time', 'Comparisons', 'Length']:\n    plt.figure(figsize=(12, 6))\n\n\n    ax = sns.boxplot(\n        x='Dataset',\n        y=metric,\n        hue='Algorithm',\n        data=df_all,\n        showfliers=True,\n        width=0.6,\n        linewidth=1.5,\n        flierprops=dict(marker='o', markersize=5))\n\n\n    config = metric_config[metric]\n    plt.title(f'{config[\"title\"]} por conjunto y algoritmo', fontsize=14, pad=15)\n    plt.ylabel(config[\"title\"], fontsize=12)\n    plt.xlabel('Conjunto de datos', fontsize=12)\n\n\n    ax.set_yscale(config[\"yscale\"])\n    ax.set_ylim(config[\"ylim\"])\n\n\n    plt.legend(\n        title='Algoritmo',\n        bbox_to_anchor=(1.05, 1),\n        loc='upper left',\n        frameon=True,\n        framealpha=0.8\n    )\n\n\n    ax.yaxis.grid(True, linestyle='--', alpha=0.7)\n    ax.xaxis.grid(False)\n\n    plt.tight_layout()\n    plt.savefig(f'boxplot_{metric}_adjusted.png', dpi=300, bbox_inches='tight')\n    plt.show()\n\n```\n\n# 7 Conclusiones\nLos experimentos realizados sobre los tres conjuntos de datos (A, B y C) permiten extraer conclusiones significativas sobre el comportamiento de los diferentes algoritmos de intersección evaluados.\n\nEn primer lugar, el algoritmo Barbay-Kenyon (BK) demostró ser el más eficiente para intersecciones m ́ultiples, mostrando tiempos de ejecución consistentes a medida que aumentaba la dimensionalidad de los conjuntos. Para el conjunto C (k=4), BK mantuvo un tiempo promedio de solo 0.000865 segundos, significativamente menor que las combinaciones por pares. Sin embargo, este algoritmo requirió un mayor número de comparaciones (3855.715 en promedio para C), lo que sugiere un equilibrio entre tiempo de ejecución y\ncomplejidad computacional.\n\nPor otro lado, los algoritmos basados en b ́usqueda binaria mostraron comportamientos diferenciados. La versión BY-BS fue la más rápida en intersecciones binarias (0.000411s en el conjunto A), mientras que su variante con doubling search (BY-B1) tambi ́en ofreció buenos resultados. En contraste, BY-B2 resultó considerablemente m ́as lento (0.002563s en A), indicando que la estrategia de incremento lineal no es óptima para estos conjuntos de\ndatos.\n\nEl método Merge Intersection (ME) presentó caracter ́ısticas particulares: aunque requirió un número elevado de comparaciones (8106.315 en A), mostró tiempos competitivos en operaciones por pares, especialmente en conjuntos grandes (0.001102s para el par 1-2 en C). Esto sugiere que su simplicidad lo hace viable cuando el nímero de comparaciones no es el factor crítico.\n\nFinalmente, el an ́alisis revel ́o que la densidad de las listas impacta directamente en los resultados. Las intersecciones en el conjunto B mostraron mayor tamaño (hasta 593.670 elementos) comparado con C (máximo 269.180), lo que resalta la importancia de seleccionar el algoritmo seg ́un las caracter ́ısticas especificas de los datos. Para trabajos futuros, se podría explorar el desarrollo de algoritmos híbridos que combinen las fortalezas de estas diferentes aproximaciones.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"variables":{"primary":"#2a7f62","dark":"#1a535c","light":"#f7fff7"},"toc":true,"toc-depth":3,"output-file":"unidad5.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":{"light":"cosmo"},"title":"5A. Reporte escrito. Experimentos y análisis de algoritmos de intersección de conjuntos.","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}