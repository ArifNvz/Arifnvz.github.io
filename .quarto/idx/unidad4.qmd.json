{"title":"4A. Reporte escrito. Experimentos y análisis de algoritmos de búsqueda por comparación.","markdown":{"yaml":{"title":"4A. Reporte escrito. Experimentos y análisis de algoritmos de búsqueda por comparación.","jupyter":"python3"},"headingText":"1. Introducción","containsRefs":false,"markdown":"\n\n\nDocente: **Dr. Eric Sadit Téllez Avila**\n\nAlumno: **Arif Narvaez de la O**\n\n\nEste documento describe la implementación y evaluación de diversos algoritmos de búsqueda aplicados a un conjunto de datos ordenado. Se han considerado cinco métodos de búsqueda distintos:\n\n1. **Búsqueda binaria acotada**\n\n2. **Búsqueda secuencial (B0)**\n\n3. **Búsqueda no acotada B1**\n\n4. **Búsqueda no acotada B2**\n\n5. **Búsqueda utilizando la estructura SkipList**\n\nEl **objetivo** es medir la eficiencia de cada algoritmo en términos de número de comparaciones y tiempo de ejecución utilizando varios archivos de consulta. Los resultados permiten analizar cuál de estas estrategias es más óptima en el contexto de datos ordenados.\n\nDe acuerdo con Cormen et al. (2009), la búsqueda binaria es óptima en listas ordenadas, mientras que Knuth (1998) destaca que la búsqueda secuencial es ineficiente en grandes volúmenes de datos. La estructura SkipList, introducida por Pugh (1990), se considera una alternativa eficiente que permite búsquedas rápidas mediante listas enlazadas con múltiples niveles.\n\n## 2. Librerias a utilizar\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nimport json\nimport time\nimport numpy as np\nimport math\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom bisect import bisect_left\nfrom sortedcontainers import SortedList\nimport random\n```\n\n## 3.Carga de datos\nEsta Secc¿cion de codigo abre y carga los datos desde un archivo JSON, extrayendo las claves y ordenándolas para facilitar las búsquedas.\n\n\n```{python}\nruta_datos = \"./archivos/p-032_ordenado.json\"\nruta_consultas = [\n    f\"./archivos/consultas-{i}-listas-posteo.json\"\n    for i in range(1, 5)\n]\n\nwith open(ruta_datos, 'r') as f:\n    datos = json.load(f)\n\ndatos_ordenados = sorted(datos.keys())\n```\n\n**Variables y su función**\n* ruta_datos: Almacena la ruta del archivo JSON que contiene la lista ordenada de claves principales.\n\n* ruta_consultas: Lista de rutas a los archivos JSON que contienen las consultas a realizar.\n\n* datos: Diccionario cargado desde el archivo JSON, con las claves como índices.\n\n* datos_ordenados: Lista de claves extraídas y ordenadas para su uso en los algoritmos de búsqueda.\n\n## 4. Implementacion de los algoritmos de busqueda\n**BUSQUEDA BINARIA**\n\nEste algoritmo tiene una complejidad de O(log n) y es eficiente para listas ordenadas (Cormen et al., 2009).\n\n\n* Función: busqueda_binaria(lista, clave)\n\n* Variables clave:\n\n  * izquierda y derecha: Definen los límites del área de búsqueda.\n\n  * medio: Calcula el punto intermedio para dividir la lista.\n\n  * comparaciones: Cuenta el número de comparaciones realizadas.\n\n```{python}\ndef busqueda_binaria(A, x):\n    \"\"\"Búsqueda binaria clásica para encontrar posición de inserción.\"\"\"\n    comparaciones = 0\n    sp, ep = 0, len(A) - 1\n\n    while sp < ep:\n        comparaciones += 1\n        mid = (sp + ep) // 2\n        if x <= A[mid]:\n            ep = mid\n        else:\n            sp = mid + 1\n\n    comparaciones += 1\n    return (sp if x <= A[sp] else sp + 1), comparaciones\n```\n\n**BUSQUEDA SECUENCIAL**\n\nEste método tiene una complejidad de O(n), lo que lo hace ineficiente en grandes volúmenes de datos (Knuth, 1998).\n\nAdemas, revisa cada elemento de la lista, de izquierda a derecha, hasta encontrar el valor buscado o llegar al final.\n\n* Función: busqueda_secuencial(lista, clave)\n\n* Variables clave:\n\n  * comparaciones: Cuenta cuántas veces se compara la clave con elementos de la list\n\n```{python}\ndef busqueda_secuencial(A, x):\n    \"\"\"Búsqueda secuencial para encontrar posición de inserción.\"\"\"\n    comparaciones = 0\n    for i, elemento in enumerate(A):\n        comparaciones += 1\n        if x <= elemento:\n            return i, comparaciones\n    return len(A), comparaciones\n```\n\n**BUSQUEDA NO ACOTADA B1**\n\nEste método selecciona posiciones aleatorias dentro de la lista y compara el valor en dichas posiciones con la clave buscada. Si después de un número fijo de intentos no encuentra el elemento, la búsqueda se considera fallida. Es menos eficiente en listas ordenadas, ya que no aprovecha la estructura de los datos. Su eficiencia depende de la distribución de los datos y la suerte en los intentos aleatorios.\n\n* Función: busqueda_no_acotada_b1(lista, clave)\n\nCaracterísticas:\n\nSe eligen 10 posiciones aleatorias para buscar la clave.\n\n```{python}\ndef busqueda_no_acotada_B1(A, x):\n    \"\"\"\n    Algoritmo B1: Búsqueda no acotada con doblado simple (doubling search/galloping)\n    Implementación según Bentley y Yao (1976)\n    \"\"\"\n    comparaciones = 0\n    n = len(A)\n\n    if n == 0:\n        return 0, 0\n\n    # Fase 1: Determinación del rango con doblado\n    i = 1\n    p = 0\n    while p + i < n and A[p + i] < x:\n        comparaciones += 1\n        p += i\n        i *= 2\n\n    # Fase 2: Búsqueda binaria en el rango encontrado\n    sp = p\n    ep = min(p + i, n - 1)\n\n    while sp < ep:\n        comparaciones += 1\n        mid = (sp + ep) // 2\n        if x <= A[mid]:\n            ep = mid\n        else:\n            sp = mid + 1\n\n    comparaciones += 1\n    return (sp if x <= A[sp] else sp + 1), comparaciones\n```\n\n**BUSQUEDA NO ACOTADA B2**\n\nEsta variante combina la búsqueda secuencial con saltos aleatorios en la lista, lo que introduce cierta aleatoriedad en la exploración. Si bien intenta mejorar la búsqueda secuencial, no logra un rendimiento estable debido a la naturaleza aleatoria de los saltos.\n\n* Función: busqueda_no_acotada_b2(lista, clave)\n\nCaracterísticas:\n\nMezcla búsqueda secuencial con saltos aleatorios.\n\n```{python}\ndef busqueda_no_acotada_B2(A, x):\n    \"\"\"\n    Algoritmo B2: Búsqueda no acotada con doblado doble (doubling-doubling search)\n    Implementación según Bentley y Yao (1976)\n    \"\"\"\n    comparaciones = 0\n    n = len(A)\n\n    if n == 0:\n        return 0, 0\n\n    # Fase 1: Determinación del rango con doblado doble\n    i = 1\n    j = 1\n    p = 0\n    while p + i < n and A[p + i] < x:\n        comparaciones += 1\n        p += i\n        i = j * j\n        j += 1\n\n    # Fase 2: Aplicar B1 en el rango encontrado\n    sp = p\n    ep = min(p + i, n - 1)\n\n    # Implementación de B1 dentro del rango\n    k = 1\n    q = sp\n    while q + k < ep and A[q + k] < x:\n        comparaciones += 1\n        q += k\n        k *= 2\n\n    # Fase 3: Búsqueda binaria en el subrango final\n    left = q\n    right = min(q + k, ep)\n\n    while left < right:\n        comparaciones += 1\n        mid = (left + right) // 2\n        if x <= A[mid]:\n            right = mid\n        else:\n            left = mid + 1\n\n    comparaciones += 1\n    return (left if x <= A[left] else left + 1), comparaciones\n```\n\n**SKIP LIST**\n\nSkipList es una estructura de datos que permite búsquedas eficientes mediante listas enlazadas con múltiples niveles de acceso. Su rendimiento es cercano al de la búsqueda binaria, con una complejidad promedio de O(logn) (Pugh, 1990).\n\n* Función: SkipList.buscar(clave)\n\n* Estructura: Utiliza SortedList para optimizar la búsqueda.\n\n```{python}\nclass SkipList:\n    \"\"\"Implementación mejorada de SkipList para búsqueda eficiente.\"\"\"\n    def __init__(self, p=0.5):\n        self.p = p\n        self.levels = []\n        self.levels.append([])  # Nivel 0 contiene todos los elementos\n\n    def insertar(self, valor):\n        # Insertar en todos los niveles necesarios\n        self.levels[0].append(valor)\n        self.levels[0].sort()  # Mantener ordenado\n\n        # Decidir si promocionar el elemento a niveles superiores\n        current_level = 0\n        while random.random() < self.p:\n            current_level += 1\n            if current_level >= len(self.levels):\n                self.levels.append([])\n\n            # Insertar en el nivel superior\n            self.levels[current_level].append(valor)\n            self.levels[current_level].sort()\n\n    def buscar(self, clave):\n        comparaciones = 0\n        # Comenzar desde el nivel más alto\n        level = len(self.levels) - 1\n        pos = -1\n\n        while level >= 0:\n            current_list = self.levels[level]\n            idx = bisect_left(current_list, clave)\n\n            if idx < len(current_list) and current_list[idx] == clave:\n                comparaciones += 1\n                return idx, comparaciones\n\n            comparaciones += 1\n            if idx > 0 and level > 0:\n                # Buscar en el rango correspondiente en el nivel inferior\n                lower_val = current_list[idx-1]\n                lower_idx = bisect_left(self.levels[level-1], lower_val)\n                pos = lower_idx\n            elif level == 0:\n                pos = idx\n\n            level -= 1\n\n        return pos, comparaciones\n\n# Preparar estructuras de datos\nskiplist = SkipList()\nfor elemento in datos_ordenados:\n    skiplist.insertar(elemento)\n```\n\n## 5. Resultados\n\nEsta función, mostrar_resultados(), tiene como objetivo convertir un diccionario de resultados (resultados) en un diccionario de DataFrames de pandas, donde cada DataFrame corresponde a una consulta específica.\n\ndf_consultas = {}:\n\n* Se inicializa un diccionario vacío que almacenará los DataFrames generados.\n\n* Las claves serán strings como \"df_consulta1\", \"df_consulta2\", etc.\n\n* Los valores serán DataFrames de pandas.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 425}\n# Función para ejecutar pruebas\ndef ejecutar_pruebas(consulta_file):\n    with open(consulta_file, 'r') as f:\n        consultas = json.load(f)\n\n    metodos = {\n        \"binaria\": busqueda_binaria,\n        \"secuencial\": busqueda_secuencial,\n        \"B1_doubling\": busqueda_no_acotada_B1,\n        \"B2_doubling-doubling\": busqueda_no_acotada_B2,\n        \"skiplist\": skiplist.buscar\n    }\n\n    resultados = {}\n\n    for nombre, metodo in metodos.items():\n        total_comparaciones = 0\n        tiempo_inicio = time.time()\n\n        for consulta in consultas:\n            clave = str(consulta)\n            if nombre == \"skiplist\":\n                _, comparaciones = metodo(clave)\n            else:\n                _, comparaciones = metodo(datos_ordenados, clave)\n            total_comparaciones += comparaciones\n\n        tiempo_total = time.time() - tiempo_inicio\n        resultados[nombre] = {\n            \"comparaciones\": total_comparaciones,\n            \"tiempo\": tiempo_total,\n            \"comparaciones_promedio\": total_comparaciones / len(consultas)\n        }\n\n    return resultados\n\n# Ejecutar pruebas para cada archivo de consultas\nresultados_totales = {}\nfor consulta_file in ruta_consultas:\n    resultados_totales[consulta_file] = ejecutar_pruebas(consulta_file)\n\n# Mostrar resultados\ndef mostrar_resultados():\n    dfs = []\n    for i, (consulta_file, datos) in enumerate(resultados_totales.items(), 1):\n        df = pd.DataFrame(datos).T\n        df['Archivo'] = f'Consulta {i}'\n        dfs.append(df)\n\n    # Concatenar todos los DataFrames\n    df_final = pd.concat(dfs)\n\n    # Reorganizar los datos para mejor visualización\n    # Primero resetear el índice para tener los nombres de métodos como columna\n    df_final = df_final.reset_index().rename(columns={'index': 'Metodo'})\n\n    # Usar melt para tener una estructura más adecuada\n    df_melted = pd.melt(df_final, id_vars=['Archivo', 'Metodo'],\n                        value_vars=['comparaciones', 'tiempo', 'comparaciones_promedio'],\n                        var_name='Metrica', value_name='Valor')\n\n    # Pivotar para tener métodos como columnas\n    df_pivoted = df_melted.pivot_table(index=['Archivo', 'Metrica'],\n                                      columns='Metodo', values='Valor')\n\n    return df_pivoted.reset_index()\n\ndf_consultas = mostrar_resultados()\ndf_consultas\n```\n\n* resultados.items():\n\n  * Asumimos que resultados es un diccionario externo con una estructura como:\n  * .items() devuelve pares (clave, valor) del diccionario.\n\n* enumerate(..., start=1):\n\n  * Numera las consultas comenzando desde 1 (en lugar de 0).\n\n  * i toma valores 1, 2, 3, ... para generar nombres como df_consulta1.\n\n  * consulta_file es la clave del diccionario (ej: \"consulta1\").\n\n  * datos es el valor asociado (ej: {\"método1\": {\"comparaciones\": 10, \"tiempo\": 0.5}, ...}).\n\n* df_nombre = f\"df_consulta{i}\":\n\n  * Genera un nombre dinámico para el DataFrame (ej: \"df_consulta1\").\n\n* pd.DataFrame(datos).T:\n\n  * datos es un diccionario anidado (ej: {\"método1\": {\"comparaciones\": 10, \"tiempo\": 0.5}}).\n\n  * pd.DataFrame(datos) lo convierte en un DataFrame donde:\n\n    * Filas: Claves del diccionario interno (\"comparaciones\", \"tiempo\").\n\n    * Columnas: Métodos de búsqueda (\"método1\", \"método2\", etc.).\n\n* .T transpone el DataFrame para que:\n\n  * Filas: Métodos de búsqueda.\n\n  * Columnas: Métricas (\"comparaciones\", \"tiempo\").\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 1\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta1 = grouped.get_group('Consulta 1').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 2\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta2 = grouped.get_group('Consulta 2').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 3\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta3 = grouped.get_group('Consulta 3').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 4\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta4 = grouped.get_group('Consulta 4').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\nplt.style.use('ggplot')\nplt.figure(figsize=(15, 10))\n\nmetricas = df_consultas['Metrica'].unique()\nmetodos = [col for col in df_consultas.columns if col not in ['Archivo', 'Metrica']]\nconsultas = df_consultas['Archivo'].unique()\n\n# Crear subgráficos para cada métrica\nfig, axes = plt.subplots(len(metricas), 1, figsize=(14, 12))\n\n# Colores para cada método\ncolors = plt.cm.get_cmap('tab10', len(metodos))\n\nfor i, metrica in enumerate(metricas):\n    ax = axes[i] if len(metricas) > 1 else axes\n    df_metrica = df_consultas[df_consultas['Metrica'] == metrica]\n\n    # Ancho de las barras\n    width = 0.15\n    x = np.arange(len(consultas))\n\n    for j, metodo in enumerate(metodos):\n        valores = df_metrica[metodo].values\n        ax.bar(x + j*width, valores, width, label=metodo, color=colors(j))\n\n\n    ax.set_title(f'Métrica: {metrica.capitalize()}', fontsize=12)\n    ax.set_xticks(x + width*(len(metodos)-1)/2)\n    ax.set_xticklabels(consultas)\n    ax.set_ylabel(metrica.capitalize())\n    ax.grid(True, linestyle='--', alpha=0.6)\n\n\n    if i == len(metricas)-1:\n        ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n\nplt.tight_layout()\nplt.suptitle('Comparación de Métodos de Búsqueda por Consulta', y=1.02, fontsize=14)\nplt.show()\n```\n\n## 6. Conclusiones\n\nLos resultados muestran que la búsqueda binaria y la estructura de datos SkipList son significativamente más eficientes en términos de número de comparaciones y tiempo de ejecución.\n\nLa búsqueda secuencial y las variantes no acotadas presentan un alto número de comparaciones y tiempos de respuesta más largos, lo que las hace menos recomendables para listas ordenadas. En particular, la búsqueda no acotada B2, que combina exploración secuencial con saltos aleatorios, mostró el peor desempeño en comparación con los demás algoritmos.\n\nPor otro lado, la implementación de estructuras avanzadas como SkipList puede optimizar la búsqueda en grandes volúmenes de datos. Su rendimiento, en algunos casos, es incluso mejor que la búsqueda binaria debido a su estructura de múltiples niveles de acceso.\n\n## 7. Referencias\n\n* Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms. MIT Press.\n\n* Knuth, D. E. (1998). The Art of Computer Programming, Volume 3: Sorting and Searching. Addison-Wesley.\n\n\n","srcMarkdownNoYaml":"\n\n\nDocente: **Dr. Eric Sadit Téllez Avila**\n\nAlumno: **Arif Narvaez de la O**\n\n\n## 1. Introducción\nEste documento describe la implementación y evaluación de diversos algoritmos de búsqueda aplicados a un conjunto de datos ordenado. Se han considerado cinco métodos de búsqueda distintos:\n\n1. **Búsqueda binaria acotada**\n\n2. **Búsqueda secuencial (B0)**\n\n3. **Búsqueda no acotada B1**\n\n4. **Búsqueda no acotada B2**\n\n5. **Búsqueda utilizando la estructura SkipList**\n\nEl **objetivo** es medir la eficiencia de cada algoritmo en términos de número de comparaciones y tiempo de ejecución utilizando varios archivos de consulta. Los resultados permiten analizar cuál de estas estrategias es más óptima en el contexto de datos ordenados.\n\nDe acuerdo con Cormen et al. (2009), la búsqueda binaria es óptima en listas ordenadas, mientras que Knuth (1998) destaca que la búsqueda secuencial es ineficiente en grandes volúmenes de datos. La estructura SkipList, introducida por Pugh (1990), se considera una alternativa eficiente que permite búsquedas rápidas mediante listas enlazadas con múltiples niveles.\n\n## 2. Librerias a utilizar\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nimport json\nimport time\nimport numpy as np\nimport math\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom bisect import bisect_left\nfrom sortedcontainers import SortedList\nimport random\n```\n\n## 3.Carga de datos\nEsta Secc¿cion de codigo abre y carga los datos desde un archivo JSON, extrayendo las claves y ordenándolas para facilitar las búsquedas.\n\n\n```{python}\nruta_datos = \"./archivos/p-032_ordenado.json\"\nruta_consultas = [\n    f\"./archivos/consultas-{i}-listas-posteo.json\"\n    for i in range(1, 5)\n]\n\nwith open(ruta_datos, 'r') as f:\n    datos = json.load(f)\n\ndatos_ordenados = sorted(datos.keys())\n```\n\n**Variables y su función**\n* ruta_datos: Almacena la ruta del archivo JSON que contiene la lista ordenada de claves principales.\n\n* ruta_consultas: Lista de rutas a los archivos JSON que contienen las consultas a realizar.\n\n* datos: Diccionario cargado desde el archivo JSON, con las claves como índices.\n\n* datos_ordenados: Lista de claves extraídas y ordenadas para su uso en los algoritmos de búsqueda.\n\n## 4. Implementacion de los algoritmos de busqueda\n**BUSQUEDA BINARIA**\n\nEste algoritmo tiene una complejidad de O(log n) y es eficiente para listas ordenadas (Cormen et al., 2009).\n\n\n* Función: busqueda_binaria(lista, clave)\n\n* Variables clave:\n\n  * izquierda y derecha: Definen los límites del área de búsqueda.\n\n  * medio: Calcula el punto intermedio para dividir la lista.\n\n  * comparaciones: Cuenta el número de comparaciones realizadas.\n\n```{python}\ndef busqueda_binaria(A, x):\n    \"\"\"Búsqueda binaria clásica para encontrar posición de inserción.\"\"\"\n    comparaciones = 0\n    sp, ep = 0, len(A) - 1\n\n    while sp < ep:\n        comparaciones += 1\n        mid = (sp + ep) // 2\n        if x <= A[mid]:\n            ep = mid\n        else:\n            sp = mid + 1\n\n    comparaciones += 1\n    return (sp if x <= A[sp] else sp + 1), comparaciones\n```\n\n**BUSQUEDA SECUENCIAL**\n\nEste método tiene una complejidad de O(n), lo que lo hace ineficiente en grandes volúmenes de datos (Knuth, 1998).\n\nAdemas, revisa cada elemento de la lista, de izquierda a derecha, hasta encontrar el valor buscado o llegar al final.\n\n* Función: busqueda_secuencial(lista, clave)\n\n* Variables clave:\n\n  * comparaciones: Cuenta cuántas veces se compara la clave con elementos de la list\n\n```{python}\ndef busqueda_secuencial(A, x):\n    \"\"\"Búsqueda secuencial para encontrar posición de inserción.\"\"\"\n    comparaciones = 0\n    for i, elemento in enumerate(A):\n        comparaciones += 1\n        if x <= elemento:\n            return i, comparaciones\n    return len(A), comparaciones\n```\n\n**BUSQUEDA NO ACOTADA B1**\n\nEste método selecciona posiciones aleatorias dentro de la lista y compara el valor en dichas posiciones con la clave buscada. Si después de un número fijo de intentos no encuentra el elemento, la búsqueda se considera fallida. Es menos eficiente en listas ordenadas, ya que no aprovecha la estructura de los datos. Su eficiencia depende de la distribución de los datos y la suerte en los intentos aleatorios.\n\n* Función: busqueda_no_acotada_b1(lista, clave)\n\nCaracterísticas:\n\nSe eligen 10 posiciones aleatorias para buscar la clave.\n\n```{python}\ndef busqueda_no_acotada_B1(A, x):\n    \"\"\"\n    Algoritmo B1: Búsqueda no acotada con doblado simple (doubling search/galloping)\n    Implementación según Bentley y Yao (1976)\n    \"\"\"\n    comparaciones = 0\n    n = len(A)\n\n    if n == 0:\n        return 0, 0\n\n    # Fase 1: Determinación del rango con doblado\n    i = 1\n    p = 0\n    while p + i < n and A[p + i] < x:\n        comparaciones += 1\n        p += i\n        i *= 2\n\n    # Fase 2: Búsqueda binaria en el rango encontrado\n    sp = p\n    ep = min(p + i, n - 1)\n\n    while sp < ep:\n        comparaciones += 1\n        mid = (sp + ep) // 2\n        if x <= A[mid]:\n            ep = mid\n        else:\n            sp = mid + 1\n\n    comparaciones += 1\n    return (sp if x <= A[sp] else sp + 1), comparaciones\n```\n\n**BUSQUEDA NO ACOTADA B2**\n\nEsta variante combina la búsqueda secuencial con saltos aleatorios en la lista, lo que introduce cierta aleatoriedad en la exploración. Si bien intenta mejorar la búsqueda secuencial, no logra un rendimiento estable debido a la naturaleza aleatoria de los saltos.\n\n* Función: busqueda_no_acotada_b2(lista, clave)\n\nCaracterísticas:\n\nMezcla búsqueda secuencial con saltos aleatorios.\n\n```{python}\ndef busqueda_no_acotada_B2(A, x):\n    \"\"\"\n    Algoritmo B2: Búsqueda no acotada con doblado doble (doubling-doubling search)\n    Implementación según Bentley y Yao (1976)\n    \"\"\"\n    comparaciones = 0\n    n = len(A)\n\n    if n == 0:\n        return 0, 0\n\n    # Fase 1: Determinación del rango con doblado doble\n    i = 1\n    j = 1\n    p = 0\n    while p + i < n and A[p + i] < x:\n        comparaciones += 1\n        p += i\n        i = j * j\n        j += 1\n\n    # Fase 2: Aplicar B1 en el rango encontrado\n    sp = p\n    ep = min(p + i, n - 1)\n\n    # Implementación de B1 dentro del rango\n    k = 1\n    q = sp\n    while q + k < ep and A[q + k] < x:\n        comparaciones += 1\n        q += k\n        k *= 2\n\n    # Fase 3: Búsqueda binaria en el subrango final\n    left = q\n    right = min(q + k, ep)\n\n    while left < right:\n        comparaciones += 1\n        mid = (left + right) // 2\n        if x <= A[mid]:\n            right = mid\n        else:\n            left = mid + 1\n\n    comparaciones += 1\n    return (left if x <= A[left] else left + 1), comparaciones\n```\n\n**SKIP LIST**\n\nSkipList es una estructura de datos que permite búsquedas eficientes mediante listas enlazadas con múltiples niveles de acceso. Su rendimiento es cercano al de la búsqueda binaria, con una complejidad promedio de O(logn) (Pugh, 1990).\n\n* Función: SkipList.buscar(clave)\n\n* Estructura: Utiliza SortedList para optimizar la búsqueda.\n\n```{python}\nclass SkipList:\n    \"\"\"Implementación mejorada de SkipList para búsqueda eficiente.\"\"\"\n    def __init__(self, p=0.5):\n        self.p = p\n        self.levels = []\n        self.levels.append([])  # Nivel 0 contiene todos los elementos\n\n    def insertar(self, valor):\n        # Insertar en todos los niveles necesarios\n        self.levels[0].append(valor)\n        self.levels[0].sort()  # Mantener ordenado\n\n        # Decidir si promocionar el elemento a niveles superiores\n        current_level = 0\n        while random.random() < self.p:\n            current_level += 1\n            if current_level >= len(self.levels):\n                self.levels.append([])\n\n            # Insertar en el nivel superior\n            self.levels[current_level].append(valor)\n            self.levels[current_level].sort()\n\n    def buscar(self, clave):\n        comparaciones = 0\n        # Comenzar desde el nivel más alto\n        level = len(self.levels) - 1\n        pos = -1\n\n        while level >= 0:\n            current_list = self.levels[level]\n            idx = bisect_left(current_list, clave)\n\n            if idx < len(current_list) and current_list[idx] == clave:\n                comparaciones += 1\n                return idx, comparaciones\n\n            comparaciones += 1\n            if idx > 0 and level > 0:\n                # Buscar en el rango correspondiente en el nivel inferior\n                lower_val = current_list[idx-1]\n                lower_idx = bisect_left(self.levels[level-1], lower_val)\n                pos = lower_idx\n            elif level == 0:\n                pos = idx\n\n            level -= 1\n\n        return pos, comparaciones\n\n# Preparar estructuras de datos\nskiplist = SkipList()\nfor elemento in datos_ordenados:\n    skiplist.insertar(elemento)\n```\n\n## 5. Resultados\n\nEsta función, mostrar_resultados(), tiene como objetivo convertir un diccionario de resultados (resultados) en un diccionario de DataFrames de pandas, donde cada DataFrame corresponde a una consulta específica.\n\ndf_consultas = {}:\n\n* Se inicializa un diccionario vacío que almacenará los DataFrames generados.\n\n* Las claves serán strings como \"df_consulta1\", \"df_consulta2\", etc.\n\n* Los valores serán DataFrames de pandas.\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 425}\n# Función para ejecutar pruebas\ndef ejecutar_pruebas(consulta_file):\n    with open(consulta_file, 'r') as f:\n        consultas = json.load(f)\n\n    metodos = {\n        \"binaria\": busqueda_binaria,\n        \"secuencial\": busqueda_secuencial,\n        \"B1_doubling\": busqueda_no_acotada_B1,\n        \"B2_doubling-doubling\": busqueda_no_acotada_B2,\n        \"skiplist\": skiplist.buscar\n    }\n\n    resultados = {}\n\n    for nombre, metodo in metodos.items():\n        total_comparaciones = 0\n        tiempo_inicio = time.time()\n\n        for consulta in consultas:\n            clave = str(consulta)\n            if nombre == \"skiplist\":\n                _, comparaciones = metodo(clave)\n            else:\n                _, comparaciones = metodo(datos_ordenados, clave)\n            total_comparaciones += comparaciones\n\n        tiempo_total = time.time() - tiempo_inicio\n        resultados[nombre] = {\n            \"comparaciones\": total_comparaciones,\n            \"tiempo\": tiempo_total,\n            \"comparaciones_promedio\": total_comparaciones / len(consultas)\n        }\n\n    return resultados\n\n# Ejecutar pruebas para cada archivo de consultas\nresultados_totales = {}\nfor consulta_file in ruta_consultas:\n    resultados_totales[consulta_file] = ejecutar_pruebas(consulta_file)\n\n# Mostrar resultados\ndef mostrar_resultados():\n    dfs = []\n    for i, (consulta_file, datos) in enumerate(resultados_totales.items(), 1):\n        df = pd.DataFrame(datos).T\n        df['Archivo'] = f'Consulta {i}'\n        dfs.append(df)\n\n    # Concatenar todos los DataFrames\n    df_final = pd.concat(dfs)\n\n    # Reorganizar los datos para mejor visualización\n    # Primero resetear el índice para tener los nombres de métodos como columna\n    df_final = df_final.reset_index().rename(columns={'index': 'Metodo'})\n\n    # Usar melt para tener una estructura más adecuada\n    df_melted = pd.melt(df_final, id_vars=['Archivo', 'Metodo'],\n                        value_vars=['comparaciones', 'tiempo', 'comparaciones_promedio'],\n                        var_name='Metrica', value_name='Valor')\n\n    # Pivotar para tener métodos como columnas\n    df_pivoted = df_melted.pivot_table(index=['Archivo', 'Metrica'],\n                                      columns='Metodo', values='Valor')\n\n    return df_pivoted.reset_index()\n\ndf_consultas = mostrar_resultados()\ndf_consultas\n```\n\n* resultados.items():\n\n  * Asumimos que resultados es un diccionario externo con una estructura como:\n  * .items() devuelve pares (clave, valor) del diccionario.\n\n* enumerate(..., start=1):\n\n  * Numera las consultas comenzando desde 1 (en lugar de 0).\n\n  * i toma valores 1, 2, 3, ... para generar nombres como df_consulta1.\n\n  * consulta_file es la clave del diccionario (ej: \"consulta1\").\n\n  * datos es el valor asociado (ej: {\"método1\": {\"comparaciones\": 10, \"tiempo\": 0.5}, ...}).\n\n* df_nombre = f\"df_consulta{i}\":\n\n  * Genera un nombre dinámico para el DataFrame (ej: \"df_consulta1\").\n\n* pd.DataFrame(datos).T:\n\n  * datos es un diccionario anidado (ej: {\"método1\": {\"comparaciones\": 10, \"tiempo\": 0.5}}).\n\n  * pd.DataFrame(datos) lo convierte en un DataFrame donde:\n\n    * Filas: Claves del diccionario interno (\"comparaciones\", \"tiempo\").\n\n    * Columnas: Métodos de búsqueda (\"método1\", \"método2\", etc.).\n\n* .T transpone el DataFrame para que:\n\n  * Filas: Métodos de búsqueda.\n\n  * Columnas: Métricas (\"comparaciones\", \"tiempo\").\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 1\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta1 = grouped.get_group('Consulta 1').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 2\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta2 = grouped.get_group('Consulta 2').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 3\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta3 = grouped.get_group('Consulta 3').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/}\nprint(f\"LISTA DE CONSULTAS 4\")\ngrouped = df_consultas.groupby('Archivo')\ndf_consulta4 = grouped.get_group('Consulta 4').copy()\n```\n\n```{python}\n#| colab: {base_uri: https://localhost:8080/, height: 1000}\nplt.style.use('ggplot')\nplt.figure(figsize=(15, 10))\n\nmetricas = df_consultas['Metrica'].unique()\nmetodos = [col for col in df_consultas.columns if col not in ['Archivo', 'Metrica']]\nconsultas = df_consultas['Archivo'].unique()\n\n# Crear subgráficos para cada métrica\nfig, axes = plt.subplots(len(metricas), 1, figsize=(14, 12))\n\n# Colores para cada método\ncolors = plt.cm.get_cmap('tab10', len(metodos))\n\nfor i, metrica in enumerate(metricas):\n    ax = axes[i] if len(metricas) > 1 else axes\n    df_metrica = df_consultas[df_consultas['Metrica'] == metrica]\n\n    # Ancho de las barras\n    width = 0.15\n    x = np.arange(len(consultas))\n\n    for j, metodo in enumerate(metodos):\n        valores = df_metrica[metodo].values\n        ax.bar(x + j*width, valores, width, label=metodo, color=colors(j))\n\n\n    ax.set_title(f'Métrica: {metrica.capitalize()}', fontsize=12)\n    ax.set_xticks(x + width*(len(metodos)-1)/2)\n    ax.set_xticklabels(consultas)\n    ax.set_ylabel(metrica.capitalize())\n    ax.grid(True, linestyle='--', alpha=0.6)\n\n\n    if i == len(metricas)-1:\n        ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n\nplt.tight_layout()\nplt.suptitle('Comparación de Métodos de Búsqueda por Consulta', y=1.02, fontsize=14)\nplt.show()\n```\n\n## 6. Conclusiones\n\nLos resultados muestran que la búsqueda binaria y la estructura de datos SkipList son significativamente más eficientes en términos de número de comparaciones y tiempo de ejecución.\n\nLa búsqueda secuencial y las variantes no acotadas presentan un alto número de comparaciones y tiempos de respuesta más largos, lo que las hace menos recomendables para listas ordenadas. En particular, la búsqueda no acotada B2, que combina exploración secuencial con saltos aleatorios, mostró el peor desempeño en comparación con los demás algoritmos.\n\nPor otro lado, la implementación de estructuras avanzadas como SkipList puede optimizar la búsqueda en grandes volúmenes de datos. Su rendimiento, en algunos casos, es incluso mejor que la búsqueda binaria debido a su estructura de múltiples niveles de acceso.\n\n## 7. Referencias\n\n* Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms. MIT Press.\n\n* Knuth, D. E. (1998). The Art of Computer Programming, Volume 3: Sorting and Searching. Addison-Wesley.\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"variables":{"primary":"#2a7f62","dark":"#1a535c","light":"#f7fff7"},"toc":true,"toc-depth":3,"output-file":"unidad4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":{"light":"cosmo"},"title":"4A. Reporte escrito. Experimentos y análisis de algoritmos de búsqueda por comparación.","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}